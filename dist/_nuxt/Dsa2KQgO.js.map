{"version":3,"file":"Dsa2KQgO.js","sources":["../../../../../../@vueuse/shared/index.mjs","../../../../../../uqr/dist/index.mjs","../../../../../../nuxt-qrcode/dist/runtime/utils/qrcode/svg/utils.js","../../../../../../nuxt-qrcode/dist/runtime/utils/qrcode/svg/variants/dots.js","../../../../../../nuxt-qrcode/dist/runtime/utils/qrcode/svg/variants/circle.js","../../../../../../nuxt-qrcode/dist/runtime/utils/qrcode/svg/variants/default.js","../../../../../../nuxt-qrcode/dist/runtime/utils/qrcode/svg/variants/pixelated.js","../../../../../../nuxt-qrcode/dist/runtime/utils/qrcode/svg/variants/rounded.js","../../../../../../nuxt-qrcode/dist/runtime/utils/qrcode/svg/markers.js","../../../../../../nuxt-qrcode/dist/runtime/utils/qrcode/svg/pixels.js","../../../../../../nuxt-qrcode/dist/runtime/utils/qrcode/svg/render.js","../../../../../../nuxt-qrcode/dist/runtime/components/qrcode.js","../../../../../../../modules/designbadge/stores/useCanvasStore.ts"],"sourcesContent":["import { shallowRef, watchEffect, readonly, watch, customRef, getCurrentScope, onScopeDispose, effectScope, getCurrentInstance, hasInjectionContext, inject, provide, ref, isRef, unref, toValue as toValue$1, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, shallowReadonly, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue';\n\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, {\n    ...options,\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  });\n  return readonly(result);\n}\n\nfunction computedWithControl(source, fn, options = {}) {\n  let v = void 0;\n  let track;\n  let trigger;\n  let dirty = true;\n  const update = () => {\n    dirty = true;\n    trigger();\n  };\n  watch(source, update, { flush: \"sync\", ...options });\n  const get = typeof fn === \"function\" ? fn : fn.get;\n  const set = typeof fn === \"function\" ? void 0 : fn.set;\n  const result = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty) {\n          v = get(v);\n          dirty = false;\n        }\n        track();\n        return v;\n      },\n      set(v2) {\n        set == null ? void 0 : set(v2);\n      }\n    };\n  });\n  result.trigger = update;\n  return result;\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createEventHook() {\n  const fns = /* @__PURE__ */ new Set();\n  const off = (fn) => {\n    fns.delete(fn);\n  };\n  const clear = () => {\n    fns.clear();\n  };\n  const on = (fn) => {\n    fns.add(fn);\n    const offFn = () => off(fn);\n    tryOnScopeDispose(offFn);\n    return {\n      off: offFn\n    };\n  };\n  const trigger = (...args) => {\n    return Promise.all(Array.from(fns).map((fn) => fn(...args)));\n  };\n  return {\n    on,\n    off,\n    trigger,\n    clear\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return (...args) => {\n    if (!initialized) {\n      state = scope.run(() => stateFactory(...args));\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nconst localProvidedStateMap = /* @__PURE__ */ new WeakMap();\n\nconst injectLocal = /* @__NO_SIDE_EFFECTS__ */ (...args) => {\n  var _a;\n  const key = args[0];\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null && !hasInjectionContext())\n    throw new Error(\"injectLocal must be called in setup\");\n  if (instance && localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance))\n    return localProvidedStateMap.get(instance)[key];\n  return inject(...args);\n};\n\nfunction provideLocal(key, value) {\n  var _a;\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"provideLocal must be called in setup\");\n  if (!localProvidedStateMap.has(instance))\n    localProvidedStateMap.set(instance, /* @__PURE__ */ Object.create(null));\n  const localProvidedState = localProvidedStateMap.get(instance);\n  localProvidedState[key] = value;\n  return provide(key, value);\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createInjectionState(composable, options) {\n  const key = (options == null ? void 0 : options.injectionKey) || Symbol(composable.name || \"InjectionState\");\n  const defaultValue = options == null ? void 0 : options.defaultValue;\n  const useProvidingState = (...args) => {\n    const state = composable(...args);\n    provideLocal(key, state);\n    return state;\n  };\n  const useInjectedState = () => injectLocal(key, defaultValue);\n  return [useProvidingState, useInjectedState];\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createRef(value, deep) {\n  if (deep === true) {\n    return ref(value);\n  } else {\n    return shallowRef(value);\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!scope) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = { ...obj };\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction reactify(fn, options) {\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : toValue$1;\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\n  };\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  let options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    options = optionsOrKeys;\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(\n    keys.map((key) => {\n      const value = obj[key];\n      return [\n        key,\n        typeof value === \"function\" ? reactify(value.bind(obj), options) : value\n      ];\n    })\n  );\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => !predicate(toValue$1(v), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));\n}\n\nconst isClient = typeof window !== \"undefined\" && typeof document !== \"undefined\";\nconst isWorker = typeof WorkerGlobalScope !== \"undefined\" && globalThis instanceof WorkerGlobalScope;\nconst isDef = (val) => typeof val !== \"undefined\";\nconst notNullish = (val) => val != null;\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\nconst isIOS = /* @__PURE__ */ getIsIOS();\nfunction getIsIOS() {\n  var _a, _b;\n  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));\n}\n\nfunction toRef(...args) {\n  if (args.length !== 1)\n    return toRef$1(...args);\n  const r = args[0];\n  return typeof r === \"function\" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);\n}\nconst resolveRef = toRef;\n\nfunction reactivePick(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => predicate(toValue$1(v), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = toValue$1(defaultValue);\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = toValue$1(defaultValue);\n      trigger();\n    }, toValue$1(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);\n    });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  let lastRejector = noop;\n  const _clearTimeout = (timer2) => {\n    clearTimeout(timer2);\n    lastRejector();\n    lastRejector = noop;\n  };\n  let lastInvoker;\n  const filter = (invoke) => {\n    const duration = toValue$1(ms);\n    const maxDuration = toValue$1(options.maxWait);\n    if (timer)\n      _clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        _clearTimeout(maxTimer);\n        maxTimer = void 0;\n      }\n      return Promise.resolve(invoke());\n    }\n    return new Promise((resolve, reject) => {\n      lastRejector = options.rejectOnCancel ? reject : resolve;\n      lastInvoker = invoke;\n      if (maxDuration && !maxTimer) {\n        maxTimer = setTimeout(() => {\n          if (timer)\n            _clearTimeout(timer);\n          maxTimer = void 0;\n          resolve(lastInvoker());\n        }, maxDuration);\n      }\n      timer = setTimeout(() => {\n        if (maxTimer)\n          _clearTimeout(maxTimer);\n        maxTimer = void 0;\n        resolve(invoke());\n      }, duration);\n    });\n  };\n  return filter;\n}\nfunction throttleFilter(...args) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  let lastRejector = noop;\n  let lastValue;\n  let ms;\n  let trailing;\n  let leading;\n  let rejectOnCancel;\n  if (!isRef(args[0]) && typeof args[0] === \"object\")\n    ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);\n  else\n    [ms, trailing = true, leading = true, rejectOnCancel = false] = args;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n      lastRejector();\n      lastRejector = noop;\n    }\n  };\n  const filter = (_invoke) => {\n    const duration = toValue$1(ms);\n    const elapsed = Date.now() - lastExec;\n    const invoke = () => {\n      return lastValue = _invoke();\n    };\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      lastValue = new Promise((resolve, reject) => {\n        lastRejector = rejectOnCancel ? reject : resolve;\n        timer = setTimeout(() => {\n          lastExec = Date.now();\n          isLeading = true;\n          resolve(invoke());\n          clear();\n        }, Math.max(0, duration - elapsed));\n      });\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n    return lastValue;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter, options = {}) {\n  const {\n    initialState = \"active\"\n  } = options;\n  const isActive = toRef(initialState === \"active\");\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive: readonly(isActive), pause, resume, eventFilter };\n}\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?\\d+\\.?\\d*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = Number.parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction pxValue(px) {\n  return px.endsWith(\"rem\") ? Number.parseFloat(px) * 16 : Number.parseFloat(px);\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\nfunction objectOmit(obj, keys, omitUndefined = false) {\n  return Object.fromEntries(Object.entries(obj).filter(([key, value]) => {\n    return (!omitUndefined || value !== void 0) && !keys.includes(key);\n  }));\n}\nfunction objectEntries(obj) {\n  return Object.entries(obj);\n}\nfunction toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\nfunction cacheStringFunction(fn) {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\n\nfunction getLifeCycleTarget(target) {\n  return target || getCurrentInstance();\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(\n    debounceFilter(ms, options),\n    fn\n  );\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  const debounced = ref(toValue$1(value));\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return shallowReadonly(debounced);\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {\n  return createFilterWrapper(\n    throttleFilter(ms, trailing, leading, rejectOnCancel),\n    fn\n  );\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(toValue$1(value));\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(\n    ref,\n    {\n      get,\n      set,\n      untrackedGet,\n      silentSet,\n      peek,\n      lay\n    },\n    { enumerable: true }\n  );\n}\nconst controlledRef = refWithControl;\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    const [target, key, value] = args;\n    target[key] = value;\n  }\n}\n\nfunction watchWithFilter(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  return watch(\n    source,\n    createFilterWrapper(\n      eventFilter,\n      cb\n    ),\n    watchOptions\n  );\n}\n\nfunction watchPausable(source, cb, options = {}) {\n  const {\n    eventFilter: filter,\n    initialState = \"active\",\n    ...watchOptions\n  } = options;\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter, { initialState });\n  const stop = watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter\n    }\n  );\n  return { stop, pause, resume, isActive };\n}\n\nfunction syncRef(left, right, ...[options]) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\",\n    transform = {}\n  } = options || {};\n  const watchers = [];\n  const transformLTR = \"ltr\" in transform && transform.ltr || ((v) => v);\n  const transformRTL = \"rtl\" in transform && transform.rtl || ((v) => v);\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchers.push(watchPausable(\n      left,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        right.value = transformLTR(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchers.push(watchPausable(\n      right,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        left.value = transformRTL(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  const stop = () => {\n    watchers.forEach((w) => w.stop());\n  };\n  return stop;\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  const targetsArray = toArray(targets);\n  return watch(\n    source,\n    (newValue) => targetsArray.forEach((target) => target.value = newValue),\n    { flush, deep, immediate }\n  );\n}\n\nfunction toRefs(objectRef, options = {}) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        var _a;\n        const replaceRef = (_a = toValue$1(options.replaceRef)) != null ? _a : true;\n        if (replaceRef) {\n          if (Array.isArray(objectRef.value)) {\n            const copy = [...objectRef.value];\n            copy[key] = v;\n            objectRef.value = copy;\n          } else {\n            const newObject = { ...objectRef.value, [key]: v };\n            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));\n            objectRef.value = newObject;\n          }\n        } else {\n          objectRef.value[key] = v;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nconst toValue = toValue$1;\nconst resolveUnref = toValue$1;\n\nfunction tryOnBeforeMount(fn, sync = true, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeMount(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnBeforeUnmount(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeUnmount(fn, target);\n}\n\nfunction tryOnMounted(fn, sync = true, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onMounted(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onUnmounted(fn, target);\n}\n\nfunction createUntil(r, isNot = false) {\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        r,\n        (v) => {\n          if (condition(v) !== isNot) {\n            if (stop)\n              stop();\n            else\n              nextTick(() => stop == null ? void 0 : stop());\n            resolve(v);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue$1(r)).finally(() => stop == null ? void 0 : stop())\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!isRef(value))\n      return toMatch((v) => v === value, options);\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        [r, value],\n        ([v1, v2]) => {\n          if (isNot !== (v1 === v2)) {\n            if (stop)\n              stop();\n            else\n              nextTick(() => stop == null ? void 0 : stop());\n            resolve(v1);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue$1(r)).finally(() => {\n          stop == null ? void 0 : stop();\n          return toValue$1(r);\n        })\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(toValue$1(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(toValue$1(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\n\nfunction defaultComparator(value, othVal) {\n  return value === othVal;\n}\n// @__NO_SIDE_EFFECTS__\nfunction useArrayDifference(...args) {\n  var _a, _b;\n  const list = args[0];\n  const values = args[1];\n  let compareFn = (_a = args[2]) != null ? _a : defaultComparator;\n  const {\n    symmetric = false\n  } = (_b = args[3]) != null ? _b : {};\n  if (typeof compareFn === \"string\") {\n    const key = compareFn;\n    compareFn = (value, othVal) => value[key] === othVal[key];\n  }\n  const diff1 = computed(() => toValue$1(list).filter((x) => toValue$1(values).findIndex((y) => compareFn(x, y)) === -1));\n  if (symmetric) {\n    const diff2 = computed(() => toValue$1(values).filter((x) => toValue$1(list).findIndex((y) => compareFn(x, y)) === -1));\n    return computed(() => symmetric ? [...toValue$1(diff1), ...toValue$1(diff2)] : toValue$1(diff1));\n  } else {\n    return diff1;\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayEvery(list, fn) {\n  return computed(() => toValue$1(list).every((element, index, array) => fn(toValue$1(element), index, array)));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayFilter(list, fn) {\n  return computed(() => toValue$1(list).map((i) => toValue$1(i)).filter(fn));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayFind(list, fn) {\n  return computed(() => toValue$1(\n    toValue$1(list).find((element, index, array) => fn(toValue$1(element), index, array))\n  ));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayFindIndex(list, fn) {\n  return computed(() => toValue$1(list).findIndex((element, index, array) => fn(toValue$1(element), index, array)));\n}\n\nfunction findLast(arr, cb) {\n  let index = arr.length;\n  while (index-- > 0) {\n    if (cb(arr[index], index, arr))\n      return arr[index];\n  }\n  return void 0;\n}\n// @__NO_SIDE_EFFECTS__\nfunction useArrayFindLast(list, fn) {\n  return computed(() => toValue$1(\n    !Array.prototype.findLast ? findLast(toValue$1(list), (element, index, array) => fn(toValue$1(element), index, array)) : toValue$1(list).findLast((element, index, array) => fn(toValue$1(element), index, array))\n  ));\n}\n\nfunction isArrayIncludesOptions(obj) {\n  return isObject(obj) && containsProp(obj, \"formIndex\", \"comparator\");\n}\n// @__NO_SIDE_EFFECTS__\nfunction useArrayIncludes(...args) {\n  var _a;\n  const list = args[0];\n  const value = args[1];\n  let comparator = args[2];\n  let formIndex = 0;\n  if (isArrayIncludesOptions(comparator)) {\n    formIndex = (_a = comparator.fromIndex) != null ? _a : 0;\n    comparator = comparator.comparator;\n  }\n  if (typeof comparator === \"string\") {\n    const key = comparator;\n    comparator = (element, value2) => element[key] === toValue$1(value2);\n  }\n  comparator = comparator != null ? comparator : (element, value2) => element === toValue$1(value2);\n  return computed(() => toValue$1(list).slice(formIndex).some((element, index, array) => comparator(\n    toValue$1(element),\n    toValue$1(value),\n    index,\n    toValue$1(array)\n  )));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayJoin(list, separator) {\n  return computed(() => toValue$1(list).map((i) => toValue$1(i)).join(toValue$1(separator)));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayMap(list, fn) {\n  return computed(() => toValue$1(list).map((i) => toValue$1(i)).map(fn));\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArrayReduce(list, reducer, ...args) {\n  const reduceCallback = (sum, value, index) => reducer(toValue$1(sum), toValue$1(value), index);\n  return computed(() => {\n    const resolved = toValue$1(list);\n    return args.length ? resolved.reduce(reduceCallback, typeof args[0] === \"function\" ? toValue$1(args[0]()) : toValue$1(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useArraySome(list, fn) {\n  return computed(() => toValue$1(list).some((element, index, array) => fn(toValue$1(element), index, array)));\n}\n\nfunction uniq(array) {\n  return Array.from(new Set(array));\n}\nfunction uniqueElementsBy(array, fn) {\n  return array.reduce((acc, v) => {\n    if (!acc.some((x) => fn(v, x, array)))\n      acc.push(v);\n    return acc;\n  }, []);\n}\n// @__NO_SIDE_EFFECTS__\nfunction useArrayUnique(list, compareFn) {\n  return computed(() => {\n    const resolvedList = toValue$1(list).map((element) => toValue$1(element));\n    return compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);\n  });\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  let _initialValue = unref(initialValue);\n  const count = shallowRef(initialValue);\n  const {\n    max = Number.POSITIVE_INFINITY,\n    min = Number.NEGATIVE_INFINITY\n  } = options;\n  const inc = (delta = 1) => count.value = Math.max(Math.min(max, count.value + delta), min);\n  const dec = (delta = 1) => count.value = Math.min(Math.max(min, count.value - delta), max);\n  const get = () => count.value;\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\n  const reset = (val = _initialValue) => {\n    _initialValue = val;\n    return set(val);\n  };\n  return { count: shallowReadonly(count), inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[T\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/i;\nconst REGEX_FORMAT = /[YMDHhms]o|\\[([^\\]]+)\\]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|z{1,4}|SSS/g;\nfunction defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {\n  let m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod)\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n}\nfunction formatOrdinal(num) {\n  const suffixes = [\"th\", \"st\", \"nd\", \"rd\"];\n  const v = num % 100;\n  return num + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);\n}\nfunction formatDate(date, formatStr, options = {}) {\n  var _a;\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  const stripTimeZone = (dateString) => {\n    var _a2;\n    return (_a2 = dateString.split(\" \")[1]) != null ? _a2 : \"\";\n  };\n  const matches = {\n    Yo: () => formatOrdinal(years),\n    YY: () => String(years).slice(-2),\n    YYYY: () => years,\n    M: () => month + 1,\n    Mo: () => formatOrdinal(month + 1),\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\n    MMM: () => date.toLocaleDateString(toValue$1(options.locales), { month: \"short\" }),\n    MMMM: () => date.toLocaleDateString(toValue$1(options.locales), { month: \"long\" }),\n    D: () => String(days),\n    Do: () => formatOrdinal(days),\n    DD: () => `${days}`.padStart(2, \"0\"),\n    H: () => String(hours),\n    Ho: () => formatOrdinal(hours),\n    HH: () => `${hours}`.padStart(2, \"0\"),\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n    ho: () => formatOrdinal(hours % 12 || 12),\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: () => String(minutes),\n    mo: () => formatOrdinal(minutes),\n    mm: () => `${minutes}`.padStart(2, \"0\"),\n    s: () => String(seconds),\n    so: () => formatOrdinal(seconds),\n    ss: () => `${seconds}`.padStart(2, \"0\"),\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\n    d: () => day,\n    dd: () => date.toLocaleDateString(toValue$1(options.locales), { weekday: \"narrow\" }),\n    ddd: () => date.toLocaleDateString(toValue$1(options.locales), { weekday: \"short\" }),\n    dddd: () => date.toLocaleDateString(toValue$1(options.locales), { weekday: \"long\" }),\n    A: () => meridiem(hours, minutes),\n    AA: () => meridiem(hours, minutes, false, true),\n    a: () => meridiem(hours, minutes, true),\n    aa: () => meridiem(hours, minutes, true, true),\n    z: () => stripTimeZone(date.toLocaleDateString(toValue$1(options.locales), { timeZoneName: \"shortOffset\" })),\n    zz: () => stripTimeZone(date.toLocaleDateString(toValue$1(options.locales), { timeZoneName: \"shortOffset\" })),\n    zzz: () => stripTimeZone(date.toLocaleDateString(toValue$1(options.locales), { timeZoneName: \"shortOffset\" })),\n    zzzz: () => stripTimeZone(date.toLocaleDateString(toValue$1(options.locales), { timeZoneName: \"longOffset\" }))\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => {\n    var _a2, _b;\n    return (_b = $1 != null ? $1 : (_a2 = matches[match]) == null ? void 0 : _a2.call(matches)) != null ? _b : match;\n  });\n}\nfunction normalizeDate(date) {\n  if (date === null)\n    return new Date(Number.NaN);\n  if (date === void 0)\n    return /* @__PURE__ */ new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n}\n// @__NO_SIDE_EFFECTS__\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n  return computed(() => formatDate(normalizeDate(toValue$1(date)), toValue$1(formatStr), options));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = shallowRef(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    const intervalValue = toValue$1(interval);\n    if (intervalValue <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    if (isActive.value)\n      timer = setInterval(cb, intervalValue);\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval) || typeof interval === \"function\") {\n    const stopWatch = watch(interval, () => {\n      if (isActive.value && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive: shallowReadonly(isActive),\n    pause,\n    resume\n  };\n}\n\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true,\n    callback\n  } = options;\n  const counter = shallowRef(0);\n  const update = () => counter.value += 1;\n  const reset = () => {\n    counter.value = 0;\n  };\n  const controls = useIntervalFn(\n    callback ? () => {\n      update();\n      callback(counter.value);\n    } : update,\n    interval,\n    { immediate }\n  );\n  if (exposeControls) {\n    return {\n      counter: shallowReadonly(counter),\n      reset,\n      ...controls\n    };\n  } else {\n    return shallowReadonly(counter);\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = shallowRef((_a = options.initialValue) != null ? _a : null);\n  watch(\n    source,\n    () => ms.value = timestamp(),\n    options\n  );\n  return shallowReadonly(ms);\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  const isPending = shallowRef(false);\n  let timer;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    if (immediateCallback)\n      cb();\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = void 0;\n      cb(...args);\n    }, toValue$1(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending: shallowReadonly(isPending),\n    start,\n    stop\n  };\n}\n\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    callback\n  } = options;\n  const controls = useTimeoutFn(\n    callback != null ? callback : noop,\n    interval,\n    options\n  );\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return {\n      ready,\n      ...controls\n    };\n  } else {\n    return ready;\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useToNumber(value, options = {}) {\n  const {\n    method = \"parseFloat\",\n    radix,\n    nanToZero\n  } = options;\n  return computed(() => {\n    let resolved = toValue$1(value);\n    if (typeof method === \"function\")\n      resolved = method(resolved);\n    else if (typeof resolved === \"string\")\n      resolved = Number[method](resolved, radix);\n    if (nanToZero && Number.isNaN(resolved))\n      resolved = 0;\n    return resolved;\n  });\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useToString(value) {\n  return computed(() => `${toValue$1(value)}`);\n}\n\n// @__NO_SIDE_EFFECTS__\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = isRef(initialValue);\n  const _value = shallowRef(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      const truthy = toValue$1(truthyValue);\n      _value.value = _value.value === truthy ? toValue$1(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [_value, toggle];\n}\n\nfunction watchArray(source, cb, options) {\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [...typeof source === \"function\" ? source() : Array.isArray(source) ? source : toValue$1(source)];\n  return watch(source, (newList, _, onCleanup) => {\n    const oldListRemains = Array.from({ length: oldList.length });\n    const added = [];\n    for (const obj of newList) {\n      let found = false;\n      for (let i = 0; i < oldList.length; i++) {\n        if (!oldListRemains[i] && obj === oldList[i]) {\n          oldListRemains[i] = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found)\n        added.push(obj);\n    }\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = [...newList];\n  }, options);\n}\n\nfunction watchAtMost(source, cb, options) {\n  const {\n    count,\n    ...watchOptions\n  } = options;\n  const current = shallowRef(0);\n  const stop = watchWithFilter(\n    source,\n    (...args) => {\n      current.value += 1;\n      if (current.value >= toValue$1(count))\n        nextTick(() => stop());\n      cb(...args);\n    },\n    watchOptions\n  );\n  return { count: current, stop };\n}\n\nfunction watchDebounced(source, cb, options = {}) {\n  const {\n    debounce = 0,\n    maxWait = void 0,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: debounceFilter(debounce, { maxWait })\n    }\n  );\n}\n\nfunction watchDeep(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      deep: true\n    }\n  );\n}\n\nfunction watchIgnorable(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  const filteredCb = createFilterWrapper(\n    eventFilter,\n    cb\n  );\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    let ignore = false;\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore = true;\n      updater();\n      ignore = false;\n    };\n    stop = watch(\n      source,\n      (...args) => {\n        if (!ignore)\n          filteredCb(...args);\n      },\n      watchOptions\n    );\n  } else {\n    const disposables = [];\n    let ignoreCounter = 0;\n    let syncCounter = 0;\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter = syncCounter;\n    };\n    disposables.push(\n      watch(\n        source,\n        () => {\n          syncCounter++;\n        },\n        { ...watchOptions, flush: \"sync\" }\n      )\n    );\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter;\n      updater();\n      ignoreCounter += syncCounter - syncCounterPrev;\n    };\n    disposables.push(\n      watch(\n        source,\n        (...args) => {\n          const ignore = ignoreCounter > 0 && ignoreCounter === syncCounter;\n          ignoreCounter = 0;\n          syncCounter = 0;\n          if (ignore)\n            return;\n          filteredCb(...args);\n        },\n        watchOptions\n      )\n    );\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nfunction watchImmediate(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      immediate: true\n    }\n  );\n}\n\nfunction watchOnce(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      once: true\n    }\n  );\n}\n\nfunction watchThrottled(source, cb, options = {}) {\n  const {\n    throttle = 0,\n    trailing = true,\n    leading = true,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: throttleFilter(throttle, trailing, leading)\n    }\n  );\n}\n\nfunction watchTriggerable(source, cb, options = {}) {\n  let cleanupFn;\n  function onEffect() {\n    if (!cleanupFn)\n      return;\n    const fn = cleanupFn;\n    cleanupFn = void 0;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  const _cb = (value, oldValue) => {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  const res = watchIgnorable(source, _cb, options);\n  const { ignoreUpdates } = res;\n  const trigger = () => {\n    let res2;\n    ignoreUpdates(() => {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return {\n    ...res,\n    trigger\n  };\n}\nfunction getWatchSources(sources) {\n  if (isReactive(sources))\n    return sources;\n  if (Array.isArray(sources))\n    return sources.map((item) => toValue$1(item));\n  return toValue$1(sources);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\n}\n\nfunction whenever(source, cb, options) {\n  const stop = watch(\n    source,\n    (v, ov, onInvalidate) => {\n      if (v) {\n        if (options == null ? void 0 : options.once)\n          nextTick(() => stop());\n        cb(v, ov, onInvalidate);\n      }\n    },\n    {\n      ...options,\n      once: false\n    }\n  );\n  return stop;\n}\n\nexport { assert, refAutoReset as autoResetRef, bypassFilter, camelize, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createRef, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, computedEager as eagerComputed, extendRef, formatDate, get, getLifeCycleTarget, hasOwn, hyphenate, identity, watchIgnorable as ignorableWatch, increaseWithUnit, injectLocal, invoke, isClient, isDef, isDefined, isIOS, isObject, isWorker, makeDestructurable, noop, normalizeDate, notNullish, now, objectEntries, objectOmit, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, provideLocal, pxValue, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toArray, toReactive, toRef, toRefs, toValue, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayDifference, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayFindLast, useArrayIncludes, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useArrayUnique, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchDeep, watchIgnorable, watchImmediate, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\n","var QrCodeDataType = /* @__PURE__ */ ((QrCodeDataType2) => {\n  QrCodeDataType2[QrCodeDataType2[\"Border\"] = -1] = \"Border\";\n  QrCodeDataType2[QrCodeDataType2[\"Data\"] = 0] = \"Data\";\n  QrCodeDataType2[QrCodeDataType2[\"Function\"] = 1] = \"Function\";\n  QrCodeDataType2[QrCodeDataType2[\"Position\"] = 2] = \"Position\";\n  QrCodeDataType2[QrCodeDataType2[\"Timing\"] = 3] = \"Timing\";\n  QrCodeDataType2[QrCodeDataType2[\"Alignment\"] = 4] = \"Alignment\";\n  return QrCodeDataType2;\n})(QrCodeDataType || {});\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst LOW = [0, 1];\nconst MEDIUM = [1, 0];\nconst QUARTILE = [2, 3];\nconst HIGH = [3, 2];\nconst EccMap = {\n  L: LOW,\n  M: MEDIUM,\n  Q: QUARTILE,\n  H: HIGH\n};\nconst NUMERIC_REGEX = /^[0-9]*$/;\nconst ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\\/:-]*$/;\nconst ALPHANUMERIC_CHARSET = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\";\nconst MIN_VERSION = 1;\nconst MAX_VERSION = 40;\nconst PENALTY_N1 = 3;\nconst PENALTY_N2 = 3;\nconst PENALTY_N3 = 40;\nconst PENALTY_N4 = 10;\nconst ECC_CODEWORDS_PER_BLOCK = [\n  // Version: (note that index 0 is for padding, and is set to an illegal value)\n  // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n  [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n  // Low\n  [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],\n  // Medium\n  [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n  // Quartile\n  [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]\n  // High\n];\nconst NUM_ERROR_CORRECTION_BLOCKS = [\n  // Version: (note that index 0 is for padding, and is set to an illegal value)\n  // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n  [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],\n  // Low\n  [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],\n  // Medium\n  [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],\n  // Quartile\n  [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]\n  // High\n];\nclass QrCode {\n  /* -- Constructor (low level) and fields -- */\n  // Creates a new QR Code with the given version number,\n  // error correction level, data codeword bytes, and mask number.\n  // This is a low-level API that most users should not use directly.\n  // A mid-level API is the encodeSegments() function.\n  constructor(version, ecc, dataCodewords, msk) {\n    this.version = version;\n    this.ecc = ecc;\n    /* -- Fields -- */\n    // The width and height of this QR Code, measured in modules, between\n    // 21 and 177 (inclusive). This is equal to version * 4 + 17.\n    __publicField(this, \"size\");\n    // The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).\n    // Even if a QR Code is created with automatic masking requested (mask = -1),\n    // the resulting object still has a mask value between 0 and 7.\n    __publicField(this, \"mask\");\n    // The modules of this QR Code (false = light, true = dark).\n    // Immutable after constructor finishes. Accessed through getModule().\n    __publicField(this, \"modules\", []);\n    __publicField(this, \"types\", []);\n    if (version < MIN_VERSION || version > MAX_VERSION)\n      throw new RangeError(\"Version value out of range\");\n    if (msk < -1 || msk > 7)\n      throw new RangeError(\"Mask value out of range\");\n    this.size = version * 4 + 17;\n    const row = Array.from({ length: this.size }, () => false);\n    for (let i = 0; i < this.size; i++) {\n      this.modules.push(row.slice());\n      this.types.push(row.map(() => 0));\n    }\n    this.drawFunctionPatterns();\n    const allCodewords = this.addEccAndInterleave(dataCodewords);\n    this.drawCodewords(allCodewords);\n    if (msk === -1) {\n      let minPenalty = 1e9;\n      for (let i = 0; i < 8; i++) {\n        this.applyMask(i);\n        this.drawFormatBits(i);\n        const penalty = this.getPenaltyScore();\n        if (penalty < minPenalty) {\n          msk = i;\n          minPenalty = penalty;\n        }\n        this.applyMask(i);\n      }\n    }\n    this.mask = msk;\n    this.applyMask(msk);\n    this.drawFormatBits(msk);\n  }\n  /* -- Accessor methods -- */\n  // Returns the color of the module (pixel) at the given coordinates, which is false\n  // for light or true for dark. The top left corner has the coordinates (x=0, y=0).\n  // If the given coordinates are out of bounds, then false (light) is returned.\n  getModule(x, y) {\n    return x >= 0 && x < this.size && y >= 0 && y < this.size && this.modules[y][x];\n  }\n  /* -- Private helper methods for constructor: Drawing function modules -- */\n  // Reads this object's version field, and draws and marks all function modules.\n  drawFunctionPatterns() {\n    for (let i = 0; i < this.size; i++) {\n      this.setFunctionModule(6, i, i % 2 === 0, QrCodeDataType.Timing);\n      this.setFunctionModule(i, 6, i % 2 === 0, QrCodeDataType.Timing);\n    }\n    this.drawFinderPattern(3, 3);\n    this.drawFinderPattern(this.size - 4, 3);\n    this.drawFinderPattern(3, this.size - 4);\n    const alignPatPos = this.getAlignmentPatternPositions();\n    const numAlign = alignPatPos.length;\n    for (let i = 0; i < numAlign; i++) {\n      for (let j = 0; j < numAlign; j++) {\n        if (!(i === 0 && j === 0 || i === 0 && j === numAlign - 1 || i === numAlign - 1 && j === 0))\n          this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);\n      }\n    }\n    this.drawFormatBits(0);\n    this.drawVersion();\n  }\n  // Draws two copies of the format bits (with its own error correction code)\n  // based on the given mask and this object's error correction level field.\n  drawFormatBits(mask) {\n    const data = this.ecc[1] << 3 | mask;\n    let rem = data;\n    for (let i = 0; i < 10; i++)\n      rem = rem << 1 ^ (rem >>> 9) * 1335;\n    const bits = (data << 10 | rem) ^ 21522;\n    for (let i = 0; i <= 5; i++)\n      this.setFunctionModule(8, i, getBit(bits, i));\n    this.setFunctionModule(8, 7, getBit(bits, 6));\n    this.setFunctionModule(8, 8, getBit(bits, 7));\n    this.setFunctionModule(7, 8, getBit(bits, 8));\n    for (let i = 9; i < 15; i++)\n      this.setFunctionModule(14 - i, 8, getBit(bits, i));\n    for (let i = 0; i < 8; i++)\n      this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));\n    for (let i = 8; i < 15; i++)\n      this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));\n    this.setFunctionModule(8, this.size - 8, true);\n  }\n  // Draws two copies of the version bits (with its own error correction code),\n  // based on this object's version field, iff 7 <= version <= 40.\n  drawVersion() {\n    if (this.version < 7)\n      return;\n    let rem = this.version;\n    for (let i = 0; i < 12; i++)\n      rem = rem << 1 ^ (rem >>> 11) * 7973;\n    const bits = this.version << 12 | rem;\n    for (let i = 0; i < 18; i++) {\n      const color = getBit(bits, i);\n      const a = this.size - 11 + i % 3;\n      const b = Math.floor(i / 3);\n      this.setFunctionModule(a, b, color);\n      this.setFunctionModule(b, a, color);\n    }\n  }\n  // Draws a 9*9 finder pattern including the border separator,\n  // with the center module at (x, y). Modules can be out of bounds.\n  drawFinderPattern(x, y) {\n    for (let dy = -4; dy <= 4; dy++) {\n      for (let dx = -4; dx <= 4; dx++) {\n        const dist = Math.max(Math.abs(dx), Math.abs(dy));\n        const xx = x + dx;\n        const yy = y + dy;\n        if (xx >= 0 && xx < this.size && yy >= 0 && yy < this.size)\n          this.setFunctionModule(xx, yy, dist !== 2 && dist !== 4, QrCodeDataType.Position);\n      }\n    }\n  }\n  // Draws a 5*5 alignment pattern, with the center module\n  // at (x, y). All modules must be in bounds.\n  drawAlignmentPattern(x, y) {\n    for (let dy = -2; dy <= 2; dy++) {\n      for (let dx = -2; dx <= 2; dx++) {\n        this.setFunctionModule(\n          x + dx,\n          y + dy,\n          Math.max(Math.abs(dx), Math.abs(dy)) !== 1,\n          QrCodeDataType.Alignment\n        );\n      }\n    }\n  }\n  // Sets the color of a module and marks it as a function module.\n  // Only used by the constructor. Coordinates must be in bounds.\n  setFunctionModule(x, y, isDark, type = QrCodeDataType.Function) {\n    this.modules[y][x] = isDark;\n    this.types[y][x] = type;\n  }\n  /* -- Private helper methods for constructor: Codewords and masking -- */\n  // Returns a new byte string representing the given data with the appropriate error correction\n  // codewords appended to it, based on this object's version and error correction level.\n  addEccAndInterleave(data) {\n    const ver = this.version;\n    const ecl = this.ecc;\n    if (data.length !== getNumDataCodewords(ver, ecl))\n      throw new RangeError(\"Invalid argument\");\n    const numBlocks = NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];\n    const blockEccLen = ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver];\n    const rawCodewords = Math.floor(getNumRawDataModules(ver) / 8);\n    const numShortBlocks = numBlocks - rawCodewords % numBlocks;\n    const shortBlockLen = Math.floor(rawCodewords / numBlocks);\n    const blocks = [];\n    const rsDiv = reedSolomonComputeDivisor(blockEccLen);\n    for (let i = 0, k = 0; i < numBlocks; i++) {\n      const dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));\n      k += dat.length;\n      const ecc = reedSolomonComputeRemainder(dat, rsDiv);\n      if (i < numShortBlocks)\n        dat.push(0);\n      blocks.push(dat.concat(ecc));\n    }\n    const result = [];\n    for (let i = 0; i < blocks[0].length; i++) {\n      blocks.forEach((block, j) => {\n        if (i !== shortBlockLen - blockEccLen || j >= numShortBlocks)\n          result.push(block[i]);\n      });\n    }\n    return result;\n  }\n  // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire\n  // data area of this QR Code. Function modules need to be marked off before this is called.\n  drawCodewords(data) {\n    if (data.length !== Math.floor(getNumRawDataModules(this.version) / 8))\n      throw new RangeError(\"Invalid argument\");\n    let i = 0;\n    for (let right = this.size - 1; right >= 1; right -= 2) {\n      if (right === 6)\n        right = 5;\n      for (let vert = 0; vert < this.size; vert++) {\n        for (let j = 0; j < 2; j++) {\n          const x = right - j;\n          const upward = (right + 1 & 2) === 0;\n          const y = upward ? this.size - 1 - vert : vert;\n          if (!this.types[y][x] && i < data.length * 8) {\n            this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));\n            i++;\n          }\n        }\n      }\n    }\n  }\n  // XORs the codeword modules in this QR Code with the given mask pattern.\n  // The function modules must be marked and the codeword bits must be drawn\n  // before masking. Due to the arithmetic of XOR, calling applyMask() with\n  // the same mask value a second time will undo the mask. A final well-formed\n  // QR Code needs exactly one (not zero, two, etc.) mask applied.\n  applyMask(mask) {\n    if (mask < 0 || mask > 7)\n      throw new RangeError(\"Mask value out of range\");\n    for (let y = 0; y < this.size; y++) {\n      for (let x = 0; x < this.size; x++) {\n        let invert;\n        switch (mask) {\n          case 0:\n            invert = (x + y) % 2 === 0;\n            break;\n          case 1:\n            invert = y % 2 === 0;\n            break;\n          case 2:\n            invert = x % 3 === 0;\n            break;\n          case 3:\n            invert = (x + y) % 3 === 0;\n            break;\n          case 4:\n            invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 === 0;\n            break;\n          case 5:\n            invert = x * y % 2 + x * y % 3 === 0;\n            break;\n          case 6:\n            invert = (x * y % 2 + x * y % 3) % 2 === 0;\n            break;\n          case 7:\n            invert = ((x + y) % 2 + x * y % 3) % 2 === 0;\n            break;\n          default:\n            throw new Error(\"Unreachable\");\n        }\n        if (!this.types[y][x] && invert)\n          this.modules[y][x] = !this.modules[y][x];\n      }\n    }\n  }\n  // Calculates and returns the penalty score based on state of this QR Code's current modules.\n  // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.\n  getPenaltyScore() {\n    let result = 0;\n    for (let y = 0; y < this.size; y++) {\n      let runColor = false;\n      let runX = 0;\n      const runHistory = [0, 0, 0, 0, 0, 0, 0];\n      for (let x = 0; x < this.size; x++) {\n        if (this.modules[y][x] === runColor) {\n          runX++;\n          if (runX === 5)\n            result += PENALTY_N1;\n          else if (runX > 5)\n            result++;\n        } else {\n          this.finderPenaltyAddHistory(runX, runHistory);\n          if (!runColor)\n            result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;\n          runColor = this.modules[y][x];\n          runX = 1;\n        }\n      }\n      result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * PENALTY_N3;\n    }\n    for (let x = 0; x < this.size; x++) {\n      let runColor = false;\n      let runY = 0;\n      const runHistory = [0, 0, 0, 0, 0, 0, 0];\n      for (let y = 0; y < this.size; y++) {\n        if (this.modules[y][x] === runColor) {\n          runY++;\n          if (runY === 5)\n            result += PENALTY_N1;\n          else if (runY > 5)\n            result++;\n        } else {\n          this.finderPenaltyAddHistory(runY, runHistory);\n          if (!runColor)\n            result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;\n          runColor = this.modules[y][x];\n          runY = 1;\n        }\n      }\n      result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * PENALTY_N3;\n    }\n    for (let y = 0; y < this.size - 1; y++) {\n      for (let x = 0; x < this.size - 1; x++) {\n        const color = this.modules[y][x];\n        if (color === this.modules[y][x + 1] && color === this.modules[y + 1][x] && color === this.modules[y + 1][x + 1])\n          result += PENALTY_N2;\n      }\n    }\n    let dark = 0;\n    for (const row of this.modules)\n      dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);\n    const total = this.size * this.size;\n    const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;\n    result += k * PENALTY_N4;\n    return result;\n  }\n  /* -- Private helper functions -- */\n  // Returns an ascending list of positions of alignment patterns for this version number.\n  // Each position is in the range [0,177), and are used on both the x and y axes.\n  // This could be implemented as lookup table of 40 variable-length lists of integers.\n  getAlignmentPatternPositions() {\n    if (this.version === 1) {\n      return [];\n    } else {\n      const numAlign = Math.floor(this.version / 7) + 2;\n      const step = this.version === 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;\n      const result = [6];\n      for (let pos = this.size - 7; result.length < numAlign; pos -= step)\n        result.splice(1, 0, pos);\n      return result;\n    }\n  }\n  // Can only be called immediately after a light run is added, and\n  // returns either 0, 1, or 2. A helper function for getPenaltyScore().\n  finderPenaltyCountPatterns(runHistory) {\n    const n = runHistory[1];\n    const core = n > 0 && runHistory[2] === n && runHistory[3] === n * 3 && runHistory[4] === n && runHistory[5] === n;\n    return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);\n  }\n  // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().\n  finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {\n    if (currentRunColor) {\n      this.finderPenaltyAddHistory(currentRunLength, runHistory);\n      currentRunLength = 0;\n    }\n    currentRunLength += this.size;\n    this.finderPenaltyAddHistory(currentRunLength, runHistory);\n    return this.finderPenaltyCountPatterns(runHistory);\n  }\n  // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().\n  finderPenaltyAddHistory(currentRunLength, runHistory) {\n    if (runHistory[0] === 0)\n      currentRunLength += this.size;\n    runHistory.pop();\n    runHistory.unshift(currentRunLength);\n  }\n}\nfunction appendBits(val, len, bb) {\n  if (len < 0 || len > 31 || val >>> len !== 0)\n    throw new RangeError(\"Value out of range\");\n  for (let i = len - 1; i >= 0; i--)\n    bb.push(val >>> i & 1);\n}\nfunction getBit(x, i) {\n  return (x >>> i & 1) !== 0;\n}\nclass QrSegment {\n  // Creates a new QR Code segment with the given attributes and data.\n  // The character count (numChars) must agree with the mode and the bit buffer length,\n  // but the constraint isn't checked. The given bit buffer is cloned and stored.\n  constructor(mode, numChars, bitData) {\n    this.mode = mode;\n    this.numChars = numChars;\n    this.bitData = bitData;\n    if (numChars < 0)\n      throw new RangeError(\"Invalid argument\");\n    this.bitData = bitData.slice();\n  }\n  /* -- Methods -- */\n  // Returns a new copy of the data bits of this segment.\n  getData() {\n    return this.bitData.slice();\n  }\n}\nconst MODE_NUMERIC = [1, 10, 12, 14];\nconst MODE_ALPHANUMERIC = [2, 9, 11, 13];\nconst MODE_BYTE = [4, 8, 16, 16];\nfunction numCharCountBits(mode, ver) {\n  return mode[Math.floor((ver + 7) / 17) + 1];\n}\nfunction makeBytes(data) {\n  const bb = [];\n  for (const b of data)\n    appendBits(b, 8, bb);\n  return new QrSegment(MODE_BYTE, data.length, bb);\n}\nfunction makeNumeric(digits) {\n  if (!isNumeric(digits))\n    throw new RangeError(\"String contains non-numeric characters\");\n  const bb = [];\n  for (let i = 0; i < digits.length; ) {\n    const n = Math.min(digits.length - i, 3);\n    appendBits(Number.parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);\n    i += n;\n  }\n  return new QrSegment(MODE_NUMERIC, digits.length, bb);\n}\nfunction makeAlphanumeric(text) {\n  if (!isAlphanumeric(text))\n    throw new RangeError(\"String contains unencodable characters in alphanumeric mode\");\n  const bb = [];\n  let i;\n  for (i = 0; i + 2 <= text.length; i += 2) {\n    let temp = ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;\n    temp += ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));\n    appendBits(temp, 11, bb);\n  }\n  if (i < text.length)\n    appendBits(ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);\n  return new QrSegment(MODE_ALPHANUMERIC, text.length, bb);\n}\nfunction makeSegments(text) {\n  if (text === \"\")\n    return [];\n  else if (isNumeric(text))\n    return [makeNumeric(text)];\n  else if (isAlphanumeric(text))\n    return [makeAlphanumeric(text)];\n  else\n    return [makeBytes(toUtf8ByteArray(text))];\n}\nfunction isNumeric(text) {\n  return NUMERIC_REGEX.test(text);\n}\nfunction isAlphanumeric(text) {\n  return ALPHANUMERIC_REGEX.test(text);\n}\nfunction getTotalBits(segs, version) {\n  let result = 0;\n  for (const seg of segs) {\n    const ccbits = numCharCountBits(seg.mode, version);\n    if (seg.numChars >= 1 << ccbits)\n      return Number.POSITIVE_INFINITY;\n    result += 4 + ccbits + seg.bitData.length;\n  }\n  return result;\n}\nfunction toUtf8ByteArray(str) {\n  str = encodeURI(str);\n  const result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.charAt(i) !== \"%\") {\n      result.push(str.charCodeAt(i));\n    } else {\n      result.push(Number.parseInt(str.substring(i + 1, i + 3), 16));\n      i += 2;\n    }\n  }\n  return result;\n}\nfunction getNumRawDataModules(ver) {\n  if (ver < MIN_VERSION || ver > MAX_VERSION)\n    throw new RangeError(\"Version number out of range\");\n  let result = (16 * ver + 128) * ver + 64;\n  if (ver >= 2) {\n    const numAlign = Math.floor(ver / 7) + 2;\n    result -= (25 * numAlign - 10) * numAlign - 55;\n    if (ver >= 7)\n      result -= 36;\n  }\n  return result;\n}\nfunction getNumDataCodewords(ver, ecl) {\n  return Math.floor(getNumRawDataModules(ver) / 8) - ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver] * NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];\n}\nfunction reedSolomonComputeDivisor(degree) {\n  if (degree < 1 || degree > 255)\n    throw new RangeError(\"Degree out of range\");\n  const result = [];\n  for (let i = 0; i < degree - 1; i++)\n    result.push(0);\n  result.push(1);\n  let root = 1;\n  for (let i = 0; i < degree; i++) {\n    for (let j = 0; j < result.length; j++) {\n      result[j] = reedSolomonMultiply(result[j], root);\n      if (j + 1 < result.length)\n        result[j] ^= result[j + 1];\n    }\n    root = reedSolomonMultiply(root, 2);\n  }\n  return result;\n}\nfunction reedSolomonComputeRemainder(data, divisor) {\n  const result = divisor.map((_) => 0);\n  for (const b of data) {\n    const factor = b ^ result.shift();\n    result.push(0);\n    divisor.forEach((coef, i) => result[i] ^= reedSolomonMultiply(coef, factor));\n  }\n  return result;\n}\nfunction reedSolomonMultiply(x, y) {\n  if (x >>> 8 !== 0 || y >>> 8 !== 0)\n    throw new RangeError(\"Byte out of range\");\n  let z = 0;\n  for (let i = 7; i >= 0; i--) {\n    z = z << 1 ^ (z >>> 7) * 285;\n    z ^= (y >>> i & 1) * x;\n  }\n  return z;\n}\nfunction encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {\n  if (!(MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= MAX_VERSION) || mask < -1 || mask > 7)\n    throw new RangeError(\"Invalid value\");\n  let version;\n  let dataUsedBits;\n  for (version = minVersion; ; version++) {\n    const dataCapacityBits2 = getNumDataCodewords(version, ecl) * 8;\n    const usedBits = getTotalBits(segs, version);\n    if (usedBits <= dataCapacityBits2) {\n      dataUsedBits = usedBits;\n      break;\n    }\n    if (version >= maxVersion)\n      throw new RangeError(\"Data too long\");\n  }\n  for (const newEcl of [MEDIUM, QUARTILE, HIGH]) {\n    if (boostEcl && dataUsedBits <= getNumDataCodewords(version, newEcl) * 8)\n      ecl = newEcl;\n  }\n  const bb = [];\n  for (const seg of segs) {\n    appendBits(seg.mode[0], 4, bb);\n    appendBits(seg.numChars, numCharCountBits(seg.mode, version), bb);\n    for (const b of seg.getData())\n      bb.push(b);\n  }\n  const dataCapacityBits = getNumDataCodewords(version, ecl) * 8;\n  appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);\n  appendBits(0, (8 - bb.length % 8) % 8, bb);\n  for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)\n    appendBits(padByte, 8, bb);\n  const dataCodewords = Array.from({ length: Math.ceil(bb.length / 8) }, () => 0);\n  bb.forEach((b, i) => dataCodewords[i >>> 3] |= b << 7 - (i & 7));\n  return new QrCode(version, ecl, dataCodewords, mask);\n}\n\nfunction encode(data, options) {\n  const {\n    ecc = \"L\",\n    boostEcc = false,\n    minVersion = 1,\n    maxVersion = 40,\n    maskPattern = -1,\n    border = 1\n  } = options || {};\n  const segment = typeof data === \"string\" ? makeSegments(data) : Array.isArray(data) ? [makeBytes(data)] : void 0;\n  if (!segment)\n    throw new Error(`uqr only supports encoding string and binary data, but got: ${typeof data}`);\n  const qr = encodeSegments(\n    segment,\n    EccMap[ecc],\n    minVersion,\n    maxVersion,\n    maskPattern,\n    boostEcc\n  );\n  const result = addBorder({\n    version: qr.version,\n    maskPattern: qr.mask,\n    size: qr.size,\n    data: qr.modules,\n    types: qr.types\n  }, border);\n  if (options?.invert)\n    result.data = result.data.map((row) => row.map((mod) => !mod));\n  options?.onEncoded?.(result);\n  return result;\n}\nfunction addBorder(input, border = 1) {\n  if (!border)\n    return input;\n  const { size } = input;\n  const newSize = size + border * 2;\n  input.size = newSize;\n  input.data.forEach((row) => {\n    for (let i = 0; i < border; i++) {\n      row.unshift(false);\n      row.push(false);\n    }\n  });\n  for (let i = 0; i < border; i++) {\n    input.data.unshift(Array.from({ length: newSize }, (_) => false));\n    input.data.push(Array.from({ length: newSize }, (_) => false));\n  }\n  const b = QrCodeDataType.Border;\n  input.types.forEach((row) => {\n    for (let i = 0; i < border; i++) {\n      row.unshift(b);\n      row.push(b);\n    }\n  });\n  for (let i = 0; i < border; i++) {\n    input.types.unshift(Array.from({ length: newSize }, (_) => b));\n    input.types.push(Array.from({ length: newSize }, (_) => b));\n  }\n  return input;\n}\nfunction getDataAt(data, x, y, defaults = false) {\n  if (x < 0 || y < 0 || x >= data.length || y >= data.length)\n    return defaults;\n  return data[y][x];\n}\n\nfunction renderUnicode(data, options = {}) {\n  const {\n    whiteChar = \"\\u2588\",\n    blackChar = \"\\u2591\"\n  } = options;\n  const result = encode(data, options);\n  return result.data.map((row) => {\n    return row.map((mod) => mod ? blackChar : whiteChar).join(\"\");\n  }).join(\"\\n\");\n}\nfunction renderANSI(data, options = {}) {\n  return renderUnicode(data, {\n    ...options,\n    blackChar: \"\\x1B[40m\\u3000\\x1B[0m\",\n    whiteChar: \"\\x1B[47m\\u3000\\x1B[0m\"\n  });\n}\nfunction renderUnicodeCompact(data, options = {}) {\n  const platte = {\n    WHITE_ALL: \"\\u2588\",\n    WHITE_BLACK: \"\\u2580\",\n    BLACK_WHITE: \"\\u2584\",\n    BLACK_ALL: \" \"\n  };\n  const result = encode(data, options);\n  const WHITE = false;\n  const BLACK = true;\n  const at = (x, y) => getDataAt(result.data, x, y, true);\n  const lines = [];\n  let line = \"\";\n  for (let row = 0; row < result.size; row += 2) {\n    for (let col = 0; col < result.size; col++) {\n      if (at(col, row) === WHITE && at(col, row + 1) === WHITE)\n        line += platte.WHITE_ALL;\n      else if (at(col, row) === WHITE && at(col, row + 1) === BLACK)\n        line += platte.WHITE_BLACK;\n      else if (at(col, row) === BLACK && at(col, row + 1) === WHITE)\n        line += platte.BLACK_WHITE;\n      else\n        line += platte.BLACK_ALL;\n    }\n    lines.push(line);\n    line = \"\";\n  }\n  return lines.join(\"\\n\");\n}\n\nfunction renderSVG(data, options = {}) {\n  const result = encode(data, options);\n  const {\n    pixelSize = 10,\n    whiteColor = \"white\",\n    blackColor = \"black\"\n  } = options;\n  const height = result.size * pixelSize;\n  const width = result.size * pixelSize;\n  let svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${width} ${height}\">`;\n  const pathes = [];\n  for (let row = 0; row < result.size; row++) {\n    for (let col = 0; col < result.size; col++) {\n      const x = col * pixelSize;\n      const y = row * pixelSize;\n      if (result.data[row][col])\n        pathes.push(`M${x},${y}h${pixelSize}v${pixelSize}h-${pixelSize}z`);\n    }\n  }\n  svg += `<rect fill=\"${whiteColor}\" width=\"${width}\" height=\"${height}\"/>`;\n  svg += `<path fill=\"${blackColor}\" d=\"${pathes.join(\"\")}\"/>`;\n  svg += \"</svg>\";\n  return svg;\n}\n\nexport { QrCodeDataType, encode, renderANSI, renderSVG, renderUnicode, renderUnicodeCompact };\n","export function getColors(options) {\n  const { whiteColor = \"white\", blackColor = \"black\", invert = false } = options;\n  return {\n    backgroundColor: invert ? blackColor : whiteColor,\n    foregroundColor: invert ? whiteColor : blackColor\n  };\n}\nexport function getSize(size, pixelSize = DEFAULT_PIXEL_SIZE) {\n  return {\n    height: size * pixelSize,\n    width: size * pixelSize\n  };\n}\nexport function getRadius(radius, defRadius = DEFAULT_RADIUS) {\n  const pixelRadius = typeof radius === \"number\" ? radius : radius?.pixel ?? defRadius;\n  const outer = typeof radius === \"number\" ? radius : radius?.marker ?? defRadius;\n  const inner = typeof radius === \"number\" ? radius : radius?.inner ?? outer;\n  return {\n    pixelRadius,\n    markerRadius: {\n      outer,\n      inner\n    }\n  };\n}\nexport function getVariant(variant, defVariant = \"default\") {\n  const pixelVariant = typeof variant === \"string\" ? variant : variant?.pixel || defVariant;\n  const outer = typeof variant === \"string\" ? variant : variant?.marker || defVariant;\n  const inner = typeof variant === \"string\" ? variant : variant?.inner || outer;\n  return {\n    pixelVariant,\n    markerVariant: {\n      outer,\n      inner\n    }\n  };\n}\nexport function limitInput(number) {\n  return Math.max(0, Math.min(1, number));\n}\nexport function renderUtils(qrSize, qrBorder) {\n  const innerSize = qrSize - qrBorder;\n  const markerSize = 7;\n  const markerPositions = [\n    [qrBorder, qrBorder],\n    [qrBorder, innerSize - markerSize],\n    [innerSize - markerSize, qrBorder]\n  ];\n  const isInMarkerRange = (value, markerStart) => value >= markerStart && value < markerStart + markerSize;\n  const isMarker = (row, col) => markerPositions.some(\n    ([x, y]) => isInMarkerRange(row, x) && isInMarkerRange(col, y)\n  );\n  const isMarkerCenter = (row, col) => markerPositions.some(\n    ([x, y]) => row >= x + 2 && row <= x + 4 && col >= y + 2 && col <= y + 4\n  );\n  return {\n    isTopLeft: (row, col) => row < markerSize && col < markerSize,\n    isTopRight: (row, col) => row < markerSize && col >= innerSize - markerSize,\n    isBottomLeft: (row, col) => row >= innerSize - markerSize && col < markerSize,\n    isMarker,\n    isMarkerCenter,\n    markerPositions,\n    markerCenterPositions: markerPositions.map(([x, y]) => [x + 2, y + 2])\n  };\n}\nexport const DEFAULT_RADIUS = 0.5;\nexport const DEFAULT_PADDING = 0.1;\nexport const DEFAULT_PIXEL_SIZE = 20;\n","import {\n  limitInput,\n  renderUtils,\n  DEFAULT_RADIUS,\n  DEFAULT_PADDING\n} from \"../utils.js\";\nexport function renderDotPixel(result, border, size, color, radius = DEFAULT_RADIUS, padding = DEFAULT_PADDING) {\n  let svg = \"\";\n  const clampedRadius = limitInput(radius);\n  const clampedPadding = limitInput(padding);\n  const actualPadding = clampedPadding * size / 2;\n  const actualSize = size - 2 * actualPadding;\n  const actualRadius = clampedRadius * actualSize / 2;\n  for (let row = 0; row < result.size; row++) {\n    for (let col = 0; col < result.size; col++) {\n      if (!renderUtils(result.size, border).isMarker(row, col) && result.data[row][col]) {\n        const x = col * size + actualPadding;\n        const y = row * size + actualPadding;\n        svg += createDotPixel(x, y, actualSize, actualRadius, color, clampedPadding);\n      }\n    }\n  }\n  return svg;\n}\nexport function renderDotMarker(result, border, size, color, radius = DEFAULT_RADIUS, padding = DEFAULT_PADDING) {\n  let svg = \"\";\n  const { markerPositions } = renderUtils(result.size, border);\n  const clampedRadius = limitInput(radius);\n  const clampedPadding = limitInput(padding);\n  const actualPadding = clampedPadding * size / 2;\n  const actualSize = size - 2 * actualPadding;\n  const actualRadius = clampedRadius * actualSize / 2;\n  markerPositions.forEach(([row, col]) => {\n    const x = col * size;\n    const y = row * size;\n    const centerSize = 3 * size;\n    for (let i = 0; i < 7; i++) {\n      for (let j = 0; j < 7; j++) {\n        if (i >= 1 && i <= 5 && j >= 1 && j <= 5) continue;\n        const pixelX = x + i * size;\n        const pixelY = y + j * size;\n        svg += createDotPixel(pixelX, pixelY, size, actualRadius, color, actualPadding);\n      }\n    }\n    svg += createDotPixel(x + 2 * size, y + 2 * size, centerSize, actualRadius * 4, color);\n  });\n  return svg;\n}\nexport function renderDotMarkerOuter(x, y, size, color, radius = DEFAULT_RADIUS, padding = DEFAULT_PADDING) {\n  let svg = \"\";\n  const clampedRadius = limitInput(radius);\n  const clampedPadding = limitInput(padding);\n  const actualPadding = clampedPadding * size / 2;\n  const actualSize = size - 2 * actualPadding;\n  const actualRadius = clampedRadius * actualSize / 2;\n  for (let i = 0; i < 7; i++) {\n    for (let j = 0; j < 7; j++) {\n      if (i >= 1 && i <= 5 && j >= 1 && j <= 5) continue;\n      const _x = i * size + x + actualPadding;\n      const _y = j * size + y + actualPadding;\n      svg += createDotPixel(_x, _y, actualSize, actualRadius, color, clampedPadding);\n    }\n  }\n  return svg;\n}\nexport function renderDotMarkerInner(x, y, size, color, radius = DEFAULT_RADIUS, padding = DEFAULT_PADDING) {\n  let svg = \"\";\n  const clampedRadius = limitInput(radius);\n  const clampedPadding = limitInput(padding);\n  const actualPadding = clampedPadding * size / 2;\n  const actualSize = size - 2 * actualPadding;\n  const actualRadius = clampedRadius * actualSize / 2;\n  for (let i = 0; i < 3; i++) {\n    for (let j = 0; j < 3; j++) {\n      const _x = i * size + x + actualPadding;\n      const _y = j * size + y + actualPadding;\n      svg += createDotPixel(_x, _y, actualSize, actualRadius, color, clampedPadding);\n    }\n  }\n  return svg;\n}\nexport function createDotPixel(x, y, size, radius, color, padding = 0) {\n  const adjustedX = x + padding;\n  const adjustedY = y + padding;\n  const adjustedSize = size - 2 * padding;\n  return `<rect \n    x=\"${adjustedX}\" \n    y=\"${adjustedY}\" \n    width=\"${adjustedSize}\" \n    height=\"${adjustedSize}\" \n    rx=\"${radius}\"\n    fill=\"${color}\"\n  />`;\n}\n","import {\n  limitInput,\n  DEFAULT_RADIUS\n} from \"../utils.js\";\nimport {\n  createDotPixel\n} from \"./dots.js\";\nexport function renderCircleMarkerOuter(x, y, size, color, radius = DEFAULT_RADIUS) {\n  const clampedRadius = limitInput(radius);\n  const _size = 6 * size;\n  const maxOuterRadius = _size / 2;\n  const outerRadius = clampedRadius * maxOuterRadius;\n  return `<rect x=\"${x + size / 2}\" y=\"${y + size / 2}\" width=\"${_size}\" height=\"${_size}\" rx=\"${outerRadius}\" fill=\"none\" stroke=\"${color}\" stroke-width=\"${size}\"/>`;\n}\nexport function renderCircleMarkerInner(x, y, size, color, radius = DEFAULT_RADIUS) {\n  const clampedRadius = limitInput(radius);\n  const _size = size * 3;\n  return createDotPixel(x, y, _size, clampedRadius * _size / 2, color);\n}\n","import { renderUtils } from \"../utils.js\";\nexport function renderDefaultPixel(result, border, size, color) {\n  const pixelPaths = [];\n  for (let row = 0; row < result.size; row++) {\n    for (let col = 0; col < result.size; col++) {\n      if (!renderUtils(result.size, border).isMarker(row, col) && result.data[row][col]) {\n        const x = col * size;\n        const y = row * size;\n        pixelPaths.push(`M${x},${y}h${size}v${size}h-${size}z`);\n      }\n    }\n  }\n  return `<path fill=\"${color}\" d=\"${pixelPaths.join(\"\")}\" shape-rendering=\"crispEdges\"/>`;\n}\nexport function renderDefaultMarkerOuter(x, y, size, color) {\n  const outerPaths = [];\n  outerPaths.push(`M${x},${y}h${7 * size}v${7 * size}h-${7 * size}z M${x + 6 * size},${y + size}h-${5 * size}v${5 * size}h${5 * size}z`);\n  return `<path fill=\"${color}\" d=\"${outerPaths.join(\"\")}\"/>`;\n}\nexport function renderDefaultMarkerInner(x, y, size, color) {\n  return `<rect x=\"${x}\" y=\"${y}\" width=\"${3 * size}\" height=\"${3 * size}\" fill=\"${color}\"/>`;\n}\n","import { renderUtils } from \"../utils.js\";\nexport function renderPixelatedPixel(result, border, size, foregroundColor) {\n  const notchSize = size / 4;\n  const paths = [];\n  for (let row = 0; row < result.size; row++) {\n    for (let col = 0; col < result.size; col++) {\n      if (!renderUtils(result.size, border).isMarker(row, col) && result.data[row][col]) {\n        const x = col * size;\n        const y = row * size;\n        paths.push(`M${x},${y}h${size}v${size}h-${size}z`);\n        paths.push(addNotches(result.data, row, col, x, y, size, notchSize));\n      }\n    }\n  }\n  return `<g shape-rendering=\"crispEdges\">\n  <path fill=\"${foregroundColor}\" d=\"${paths.join(\"\")}\"/>\n</g>`;\n}\nexport function renderPixelatedMarkerOuter(x, y, size, color) {\n  const notchSize = size / 4;\n  const outerPaths = [];\n  outerPaths.push(`M${x},${y}h${7 * size}v${7 * size}h-${7 * size}z M${x + 6 * size},${y + size}h-${5 * size}v${5 * size}h${5 * size}z M${x + notchSize},${y}h-${notchSize}v${notchSize}h${notchSize}z M${x + 7 * size},${y}h-${notchSize}v${notchSize}h${notchSize}z M${x},${y + 7 * size}h${notchSize}v-${notchSize}h-${notchSize}z M${x + 7 * size - notchSize},${y + 7 * size}h${notchSize}v-${notchSize}h-${notchSize}z`);\n  return `<g shape-rendering=\"crispEdges\">\n  <path fill=\"${color}\" d=\"${outerPaths.join(\"\")}\"/>\n</g>`;\n}\nexport function renderPixelatedMarkerInner(x, y, size, color) {\n  const notchSize = size / 4;\n  const outerPaths = [];\n  outerPaths.push(`M${x},${y}h${3 * size}v${3 * size}h-${3 * size}z M${x + notchSize},${y}h-${notchSize}v${notchSize}h${notchSize}z M${x + 3 * size},${y}h-${notchSize}v${notchSize}h${notchSize}z M${x},${y + 3 * size}h${notchSize}v-${notchSize}h-${notchSize}z M${x + 3 * size - notchSize},${y + 3 * size}h${notchSize}v-${notchSize}h-${notchSize}z`);\n  return `<g shape-rendering=\"crispEdges\">\n  <path fill=\"${color}\" d=\"${outerPaths.join(\"\")}\"/>\n</g>`;\n}\nfunction addNotches(data, row, col, x, y, size, notchSize) {\n  const checkPixel = (r, c) => {\n    if (r < 0 || r >= data.length || c < 0 || c >= data[0].length) return false;\n    return data[r][c];\n  };\n  let notches = \"\";\n  if (!checkPixel(row - 1, col) && !checkPixel(row, col - 1)) {\n    notches += `M${x + notchSize},${y}h-${notchSize}v${notchSize}h${notchSize}v-${notchSize}z`;\n  }\n  if (!checkPixel(row - 1, col) && !checkPixel(row, col + 1)) {\n    notches += `M${x + notchSize * 2},${y}h${notchSize}v${notchSize}h${notchSize}v-${notchSize}z`;\n  }\n  if (!checkPixel(row + 0, col + 1) && !checkPixel(row + 1, col + 0)) {\n    notches += `M${x + size},${y + size - notchSize}h-${notchSize}v${notchSize}h${notchSize}v-${notchSize}z`;\n  }\n  if (!checkPixel(row + 1, col) && !checkPixel(row + 0, col - 1)) {\n    notches += `M${x + notchSize},${y + size - notchSize}h-${notchSize}v${notchSize}h${notchSize}v-${notchSize}z`;\n  }\n  return notches;\n}\n","import {\n  limitInput,\n  renderUtils,\n  DEFAULT_RADIUS\n} from \"../utils.js\";\nexport function renderRoundedPixel(result, border, size, color, radius = DEFAULT_RADIUS) {\n  const paths = [];\n  const visited = Array(result.size).fill(null).map(() => Array(result.size).fill(false));\n  const clampedRadius = limitInput(radius);\n  const actualRadius = clampedRadius * size / 2;\n  for (let row = 0; row < result.size; row++) {\n    for (let col = 0; col < result.size; col++) {\n      if (!renderUtils(result.size, border).isMarker(row, col) && result.data[row][col] && !visited[row][col]) {\n        paths.push(tracePath(result.data, visited, row, col, size, actualRadius));\n      }\n    }\n  }\n  return `<path fill=\"${color}\" d=\"${paths.join(\" \")}\"/>`;\n}\nexport function renderRoundedMarkerOuter(x, y, size, color, radius = DEFAULT_RADIUS) {\n  const clampedRadius = limitInput(radius);\n  const actualRadius = clampedRadius * size / 2;\n  const outerPath = createRoundedRectPath(x, y, 7 * size, 7 * size, actualRadius);\n  const innerPath = createReversedRoundedRectPath(x + size, y + size, 5 * size, 5 * size, actualRadius);\n  return `<path fill=\"${color}\" d=\"${outerPath} ${innerPath}\"/>`;\n}\nexport function renderRoundedMarkerInner(x, y, size, color, radius = DEFAULT_RADIUS) {\n  const clampedRadius = limitInput(radius);\n  const actualRadius = clampedRadius * size / 2;\n  const path = createRoundedRectPath(x, y, 3 * size, 3 * size, actualRadius);\n  return `<path fill=\"${color}\" d=\"${path}\"/>`;\n}\nfunction tracePath(data, visited, startRow, startCol, pixelSize, cornerRadius) {\n  const path = [];\n  const stack = [[startRow, startCol]];\n  while (stack.length > 0) {\n    const [row, col] = stack.pop();\n    if (row < 0 || row >= data.length || col < 0 || col >= data[0].length || !data[row][col] || visited[row][col]) {\n      continue;\n    }\n    visited[row][col] = true;\n    const x = col * pixelSize;\n    const y = row * pixelSize;\n    const top = row > 0 && data[row - 1][col];\n    const right = col < data[0].length - 1 && data[row][col + 1];\n    const bottom = row < data.length - 1 && data[row + 1][col];\n    const left = col > 0 && data[row][col - 1];\n    path.push(createPixelPath(x, y, pixelSize, cornerRadius, { top, right, bottom, left }));\n    stack.push([row - 1, col], [row, col + 1], [row + 1, col], [row, col - 1]);\n  }\n  return path.join(\" \");\n}\nfunction createPixelPath(x, y, size, radius = DEFAULT_RADIUS, { top, right, bottom, left }) {\n  const commands = [];\n  const adjustedRadius = Math.min(radius, size / 2);\n  const curve = adjustedRadius * (4 / 3) * Math.tan(Math.PI / 8);\n  if (!left && !top) {\n    commands.push(`M${x},${y + adjustedRadius}`);\n    commands.push(`C${x},${y + adjustedRadius - curve} ${x + adjustedRadius - curve},${y} ${x + adjustedRadius},${y}`);\n  } else {\n    commands.push(`M${x},${y}`);\n  }\n  if (!top && !right) {\n    commands.push(`L${x + size - adjustedRadius},${y}`);\n    commands.push(`C${x + size - adjustedRadius + curve},${y} ${x + size},${y + adjustedRadius - curve} ${x + size},${y + adjustedRadius}`);\n  } else {\n    commands.push(`L${x + size},${y}`);\n  }\n  if (!right && !bottom) {\n    commands.push(`L${x + size},${y + size - adjustedRadius}`);\n    commands.push(`C${x + size},${y + size - adjustedRadius + curve} ${x + size - adjustedRadius + curve},${y + size} ${x + size - adjustedRadius},${y + size}`);\n  } else {\n    commands.push(`L${x + size},${y + size}`);\n  }\n  if (!bottom && !left) {\n    commands.push(`L${x + adjustedRadius},${y + size}`);\n    commands.push(`C${x + adjustedRadius - curve},${y + size} ${x},${y + size - adjustedRadius + curve} ${x},${y + size - adjustedRadius}`);\n  } else {\n    commands.push(`L${x},${y + size}`);\n  }\n  commands.push(\"Z\");\n  return commands.join(\" \");\n}\nfunction createRoundedRectPath(x, y, width, height, radius = DEFAULT_RADIUS) {\n  const adjustedRadius = Math.min(radius, Math.min(width, height) / 2);\n  const curve = adjustedRadius * (4 / 3) * Math.tan(Math.PI / 8);\n  return [\n    `M${x + adjustedRadius},${y}`,\n    `H${x + width - adjustedRadius}`,\n    `C${x + width - adjustedRadius + curve},${y} ${x + width},${y + adjustedRadius - curve} ${x + width},${y + adjustedRadius}`,\n    `V${y + height - adjustedRadius}`,\n    `C${x + width},${y + height - adjustedRadius + curve} ${x + width - adjustedRadius + curve},${y + height} ${x + width - adjustedRadius},${y + height}`,\n    `H${x + adjustedRadius}`,\n    `C${x + adjustedRadius - curve},${y + height} ${x},${y + height - adjustedRadius + curve} ${x},${y + height - adjustedRadius}`,\n    `V${y + adjustedRadius}`,\n    `C${x},${y + adjustedRadius - curve} ${x + adjustedRadius - curve},${y} ${x + adjustedRadius},${y}`,\n    \"Z\"\n  ].join(\" \");\n}\nfunction createReversedRoundedRectPath(x, y, width, height, radius = DEFAULT_RADIUS) {\n  const adjustedRadius = Math.min(radius, Math.min(width, height) / 2);\n  const curve = adjustedRadius * (4 / 3) * Math.tan(Math.PI / 8);\n  return [\n    `M${x + width - adjustedRadius},${y}`,\n    `H${x + adjustedRadius}`,\n    `C${x + adjustedRadius - curve},${y} ${x},${y + adjustedRadius - curve} ${x},${y + adjustedRadius}`,\n    `V${y + height - adjustedRadius}`,\n    `C${x},${y + height - adjustedRadius + curve} ${x + adjustedRadius - curve},${y + height} ${x + adjustedRadius},${y + height}`,\n    `H${x + width - adjustedRadius}`,\n    `C${x + width - adjustedRadius + curve},${y + height} ${x + width},${y + height - adjustedRadius + curve} ${x + width},${y + height - adjustedRadius}`,\n    `V${y + adjustedRadius}`,\n    `C${x + width},${y + adjustedRadius - curve} ${x + width - adjustedRadius + curve},${y} ${x + width - adjustedRadius},${y}`,\n    \"Z\"\n  ].join(\" \");\n}\n","import {\n  renderUtils\n} from \"./utils.js\";\nimport {\n  renderCircleMarkerOuter,\n  renderCircleMarkerInner,\n  renderDefaultMarkerOuter,\n  renderDefaultMarkerInner,\n  renderDotMarkerOuter,\n  renderDotMarkerInner,\n  renderPixelatedMarkerOuter,\n  renderPixelatedMarkerInner,\n  renderRoundedMarkerOuter,\n  renderRoundedMarkerInner\n} from \"./variants/index.js\";\nexport function renderMarkers(result, border = 1, size, color, variant, radius, padding) {\n  const { markerPositions } = renderUtils(result.size, border);\n  let svg = \"\";\n  markerPositions.forEach(([row, col]) => {\n    const ox = col * size;\n    const oy = row * size;\n    const ix = ox + 2 * size;\n    const iy = oy + 2 * size;\n    svg += markerOuterVariants(variant.outer, ox, oy, size, color, radius?.outer, padding);\n    svg += markerInnerVariants(variant.inner, ix, iy, size, color, radius?.inner, padding);\n  });\n  return svg;\n}\nexport function markerOuterVariants(variant = \"default\", x, y, size, color, radius, padding) {\n  switch (variant) {\n    case \"dots\":\n      return renderDotMarkerOuter(x, y, size, color, radius, padding);\n    case \"circle\":\n      return renderCircleMarkerOuter(x, y, size, color, radius);\n    case \"rounded\":\n      return renderRoundedMarkerOuter(x, y, size, color, radius);\n    case \"pixelated\":\n      return renderPixelatedMarkerOuter(x, y, size, color);\n    case \"default\":\n    default:\n      return renderDefaultMarkerOuter(x, y, size, color);\n  }\n}\nexport function markerInnerVariants(variant = \"default\", x, y, size, color, radius, padding) {\n  switch (variant) {\n    case \"dots\":\n      return renderDotMarkerInner(x, y, size, color, radius, padding);\n    case \"circle\":\n      return renderCircleMarkerInner(x, y, size, color, radius);\n    case \"rounded\":\n      return renderRoundedMarkerInner(x, y, size, color, radius);\n    case \"pixelated\":\n      return renderPixelatedMarkerInner(x, y, size, color);\n    case \"default\":\n    default:\n      return renderDefaultMarkerInner(x, y, size, color);\n  }\n}\n","import {\n  renderDefaultPixel,\n  renderDotPixel,\n  renderRoundedPixel,\n  renderPixelatedPixel\n} from \"./variants/index.js\";\nexport function renderPixels(result, border = 1, size, color, variant = \"default\", radius, padding) {\n  switch (variant) {\n    case \"circle\":\n    case \"dots\":\n      return renderDotPixel(result, border, size, color, radius, padding);\n    case \"rounded\":\n      return renderRoundedPixel(result, border, size, color, radius);\n    case \"pixelated\":\n      return renderPixelatedPixel(result, border, size, color);\n    case \"default\":\n    default:\n      return renderDefaultPixel(result, border, size, color);\n  }\n}\n","import { encode } from \"uqr\";\nimport { base64Encode } from \"../..//index.js\";\nimport {\n  renderMarkers\n} from \"./markers.js\";\nimport {\n  renderPixels\n} from \"./pixels.js\";\nimport {\n  getColors,\n  getSize,\n  getRadius,\n  getVariant,\n  DEFAULT_PIXEL_SIZE\n} from \"./utils.js\";\nexport function renderSVG(data, options = {}) {\n  const {\n    radius,\n    pixelSize,\n    pixelPadding,\n    variant,\n    ...opts\n  } = options;\n  const result = encode(data, opts);\n  const { width, height } = getSize(result.size, pixelSize);\n  let svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${width} ${height}\">`;\n  svg += renderSVGBody(result, options);\n  svg += \"</svg>\";\n  return svg;\n}\nexport function renderSVGBase64(data, options = {}) {\n  return `data:image/svg+xml;base64,${base64Encode(renderSVG(data, options))}`;\n}\nexport function renderSVGBody(result, options = {}) {\n  const {\n    radius,\n    pixelSize = DEFAULT_PIXEL_SIZE,\n    pixelPadding,\n    variant,\n    border\n  } = options;\n  const { backgroundColor, foregroundColor } = getColors(options);\n  const { width, height } = getSize(result.size, pixelSize);\n  let svgBody = `<rect fill=\"${backgroundColor}\" width=\"${width}\" height=\"${height}\"/>`;\n  const { pixelRadius, markerRadius } = getRadius(radius);\n  const { pixelVariant, markerVariant } = getVariant(variant);\n  svgBody += renderPixels(result, border, pixelSize, foregroundColor, pixelVariant, pixelRadius, pixelPadding);\n  svgBody += renderMarkers(result, border, pixelSize, foregroundColor, markerVariant, markerRadius, pixelPadding);\n  return svgBody;\n}\n","import { defu } from \"defu\";\nimport { reactivePick } from \"@vueuse/core\";\nimport { encode } from \"uqr\";\nimport { computed, toRef, defineComponent, h, useRuntimeConfig } from \"#imports\";\nimport { renderSVGBody } from \"#qrcode/utils/qrcode/svg/render\";\nimport { getSize } from \"#qrcode/utils/qrcode/svg/utils\";\nexport default defineComponent({\n  name: \"Qrcode\",\n  props: {\n    value: {\n      type: [String, Array],\n      required: true\n    },\n    width: {\n      type: [Number, String]\n    },\n    height: {\n      type: [Number, String]\n    },\n    variant: {\n      type: [String, Object]\n    },\n    radius: {\n      type: [Number, Object]\n    },\n    pixelPadding: {\n      type: Number\n    },\n    preserveAspectRatio: {\n      type: String\n    },\n    blackColor: {\n      type: String\n    },\n    whiteColor: {\n      type: String\n    },\n    boostEcc: {\n      type: Boolean\n    },\n    border: {\n      type: Number\n    },\n    ecc: {\n      type: String\n    },\n    invert: {\n      type: Boolean\n    },\n    maskPattern: {\n      type: Number\n    },\n    maxVersion: {\n      type: Number\n    },\n    minVersion: {\n      type: Number\n    },\n    onEncoded: {\n      type: Function\n    },\n    pixelSize: {\n      type: Number\n    }\n  },\n  emits: [\"encoded\"],\n  setup(props, { attrs, emit }) {\n    const _options = reactivePick(props, (_, key) => key !== \"value\");\n    const valueRef = toRef(props, \"value\");\n    const options = computed(() => {\n      return defu(\n        _options,\n        useRuntimeConfig().public.qrcode.options\n      );\n    });\n    const qr = computed(() => {\n      const {\n        // @ts-expect-error value is not in options, but destructuring it for safety\n        value,\n        radius,\n        pixelSize,\n        pixelPadding,\n        variant,\n        // SVGAttrs\n        width,\n        height,\n        preserveAspectRatio,\n        // render body\n        whiteColor,\n        blackColor,\n        invert,\n        // encode options\n        ...opts\n      } = options.value;\n      const result = encode(valueRef.value, {\n        ...opts,\n        onEncoded: (qr2) => {\n          if (opts.onEncoded)\n            opts.onEncoded(qr2);\n          emit(\"encoded\", qr2);\n        }\n      });\n      const s = getSize(result.size, pixelSize);\n      return h(\"svg\", {\n        ...attrs,\n        width,\n        height,\n        preserveAspectRatio,\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: `0 0 ${s.width} ${s.height}`,\n        innerHTML: renderSVGBody(\n          result,\n          {\n            radius,\n            pixelSize,\n            pixelPadding,\n            variant,\n            border: opts.border,\n            whiteColor,\n            blackColor,\n            invert\n          }\n        )\n      });\n    });\n    return () => qr.value;\n  }\n});\n","import { defineStore } from \"pinia\";\r\nimport { usePageStore } from \"./usePageStore\";\r\ninterface Size {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\ninterface Variant {\r\n  inner: string;\r\n  marker: string;\r\n  pixel: string;\r\n}\r\n\r\ninterface QRCode {\r\n  value: string;\r\n  variant: string;\r\n  radius: number;\r\n  blackColor: string;\r\n  whiteColor: string;\r\n}\r\n\r\ninterface Position {\r\n  left: number;\r\n  top: number;\r\n}\r\n\r\ninterface ElementProperties {\r\n  size: Size;\r\n  rotation: number;\r\n  font: string;\r\n  fontWeight: string;\r\n  fontStyle: string;\r\n  fontSize: string | number;\r\n  fillColor: string;\r\n  fillTransparency: boolean;\r\n  textDecoration: string;\r\n  color: string;\r\n  textAlign: string;\r\n  verticalAlign: string;\r\n  horizontalAlign: string;\r\n  textTransform: string;\r\n  src: string;\r\n  strokeColor: string;\r\n  strokeWidth: number;\r\n  associatedData: string;\r\n  content: string;\r\n  x: number;\r\n  y: number;\r\n  text: string;\r\n  displayOption?: string;\r\n  qrcode: QRCode;\r\n  direction: string;\r\n}\r\n\r\ninterface CanvasElement {\r\n  id: string | number;\r\n  text: string;\r\n  type: string;\r\n  label: string;\r\n  position: Position;\r\n  properties: ElementProperties;\r\n  isSelected: boolean;\r\n  isDragging: boolean;\r\n  visible: boolean;\r\n}\r\n\r\nexport const useCanvasStore = defineStore(\"canvasStore\", {\r\n  state: () => ({\r\n    activeTab: \"design\" as string,\r\n    frontBoxes: [] as CanvasElement[],\r\n    backBoxes: [] as CanvasElement[],\r\n    activeSide: \"front\" as \"front\" | \"back\",\r\n    selectedElement: null as string | number | null,\r\n    selectedElementType: null as string | null,\r\n    currentProperties: {} as Partial<ElementProperties>,\r\n    dropzone: null as HTMLElement | null,\r\n    showImageModal: false,\r\n    showGradientModal: false,\r\n    showColorModal: false,\r\n    frontBackground: null as string | null, // Background for front side\r\n    backBackground: null as string | null, // Background for back side\r\n    pendingImagePosition: null as Position | null,\r\n    pendingImageSide: null as \"front\" | \"back\" | null,\r\n    cursorPosition: null as { node: Node; offset: number } | null,\r\n    dropdownOpen: false as boolean,\r\n    imageItem: null as string | any,\r\n  }),\r\n  getters: {\r\n    boxes: (state): CanvasElement[] =>\r\n      state.activeSide === \"front\" ? state.frontBoxes : state.backBoxes,\r\n    currentBackground: (state): string | null =>\r\n      state.activeSide === \"front\"\r\n        ? state.frontBackground\r\n        : state.backBackground,\r\n  },\r\n  actions: {\r\n    elementMachanism(data?: any) {\r\n      const item = data.item;\r\n      const position = data.position;\r\n\r\n      const newElement: CanvasElement = {\r\n        id: Date.now(),\r\n        text: item.value || \"Sample Text\",\r\n        type: item.type,\r\n        label: `${item.label}`,\r\n        position,\r\n        properties: {\r\n          size: { width: data.width ?? \"\", height: data.height ?? \"\" },\r\n          rotation: 0,\r\n          font: \"Roboto\",\r\n          fontWeight: \"normal\",\r\n          fontStyle: \"normal\",\r\n          fontSize: \"Auto\",\r\n          fillColor: item.type === \"rectangle\" ? \"blue\" : \"transparent\",\r\n          fillTransparency: false,\r\n          textDecoration: \"none\",\r\n          color: \"black\",\r\n          textAlign: item.type === \"h1\" || item.type === \"p\" ? \"center\" : \"\",\r\n          verticalAlign:\r\n            item.type === \"h1\" || item.type === \"p\" ? \"middle\" : \"\",\r\n          horizontalAlign:\r\n            item.type === \"h1\" || item.type === \"p\" ? \"center\" : \"\",\r\n          textTransform: \"none\",\r\n          src: data.dataUrl ?? \"\",\r\n          strokeColor: \"\",\r\n          strokeWidth: 0,\r\n          associatedData: \"\",\r\n          content: \"\",\r\n          x: position.left,\r\n          y: position.top,\r\n          text: item.label || \"Sample Text\",\r\n          displayOption: \"both sides\",\r\n          qrcode: data.qrcode ?? \"\",\r\n          direction: \"ltr\",\r\n        },\r\n        isSelected: true,\r\n        isDragging: false,\r\n        visible: true,\r\n      };\r\n\r\n      return newElement;\r\n    },\r\n    addElementFromDrag(item: any, position: Position) {\r\n      // Ensure position is within drop zone\r\n      const pageStore = usePageStore();\r\n      const canvasWidth =\r\n        this.dropzone?.offsetWidth || pageStore.presetWidth * 3.78;\r\n      const canvasHeight =\r\n        this.dropzone?.offsetHeight || pageStore.presetHeight * 3.78;\r\n      const elementWidth = 200; // Default width\r\n      const elementHeight = 64; // Default height\r\n\r\n      const adjustedPosition = {\r\n        left: Math.max(0, Math.min(position.left, canvasWidth - elementWidth)),\r\n        top: Math.max(0, Math.min(position.top, canvasHeight - elementHeight)),\r\n      };\r\n\r\n      const data = {\r\n        item: item,\r\n        position: adjustedPosition,\r\n        width: elementWidth,\r\n        height: elementHeight,\r\n      };\r\n\r\n      const newElement = this.elementMachanism(data);\r\n\r\n      this.addElement(newElement);\r\n      this.selectedElement = newElement.id;\r\n      this.updateProperties();\r\n    },\r\n\r\n    handleImageUploaded(dataUrl: string) {\r\n      // if (item.type === \"img\" || item.type === \"background\") {\r\n      //   this.imageItem = item;\r\n      //   this.showImageModal = true;\r\n      const position = { left: 123, top: 204 };\r\n      this.pendingImagePosition = position;\r\n      this.pendingImageSide = this.activeSide;\r\n      //   return;\r\n      // }\r\n\r\n      const pageStore = usePageStore();\r\n      const customPosition = {\r\n        left: 198,\r\n        top: 277,\r\n      };\r\n      const canvasWidth =\r\n        this.dropzone?.offsetWidth || pageStore.presetWidth * 3.78;\r\n      const canvasHeight =\r\n        this.dropzone?.offsetHeight || pageStore.presetHeight * 3.78;\r\n      const elementWidth =\r\n        this.imageItem.type === \"background\"\r\n          ? pageStore.presetWidth * 3.78\r\n          : 150;\r\n      const elementHeight =\r\n        this.imageItem.type === \"background\"\r\n          ? pageStore.presetHeight * 3.78\r\n          : 150;\r\n\r\n      // Ensure position is within drop zone\r\n      const adjustedPosition = {\r\n        left: Math.max(\r\n          0,\r\n          Math.min(\r\n            this.imageItem.type === \"background\"\r\n              ? customPosition.left\r\n              : this.pendingImagePosition.left,\r\n            canvasWidth - elementWidth\r\n          )\r\n        ),\r\n        top: Math.max(\r\n          0,\r\n          Math.min(\r\n            this.imageItem.type === \"background\"\r\n              ? customPosition.top\r\n              : this.pendingImagePosition.top,\r\n            canvasHeight - elementHeight\r\n          )\r\n        ),\r\n      };\r\n\r\n      const data = {\r\n        item: {\r\n          text: this.imageItem.label,\r\n          type: this.imageItem.type,\r\n          label: this.imageItem.type === \"background\" ? \"background\" : \"Image\",\r\n        },\r\n        position: adjustedPosition,\r\n        dataUrl: dataUrl,\r\n        width: elementWidth,\r\n        height: elementHeight,\r\n      };\r\n\r\n      const newElement = this.elementMachanism(data);\r\n\r\n      if (this.pendingImageSide === \"front\") {\r\n        this.frontBoxes.push(newElement);\r\n      } else {\r\n        this.backBoxes.push(newElement);\r\n      }\r\n      this.pendingImagePosition = null;\r\n      this.pendingImageSide = null;\r\n      this.selectedElement = newElement.id;\r\n      this.updateProperties();\r\n    },\r\n\r\n    addElement(element: CanvasElement) {\r\n      if (this.activeSide === \"front\") {\r\n        this.frontBoxes.push(element);\r\n      } else {\r\n        this.backBoxes.push(element);\r\n      }\r\n    },\r\n\r\n    // handleImageUploaded(dataUrl: string) {\r\n    //   if (this.pendingImagePosition && this.pendingImageSide) {\r\n    //     const pageStore = usePageStore();\r\n    //     const customPosition = {\r\n    //       left: 198,\r\n    //       top: 277,\r\n    //     };\r\n    //     const data = {\r\n    //       item: {\r\n    //         text: this.imageItem.label,\r\n    //         type: this.imageItem.type,\r\n    //         label:\r\n    //           this.imageItem.type === \"background\" ? \"background\" : \"Image\",\r\n    //       },\r\n    //       position:\r\n    //         this.imageItem.type === \"background\"\r\n    //           ? customPosition\r\n    //           : this.pendingImagePosition,\r\n    //       dataUrl: dataUrl,\r\n    //       width:\r\n    //         this.imageItem.type === \"background\"\r\n    //           ? pageStore.presetWidth * 3.78\r\n    //           : 150,\r\n    //       height:\r\n    //         this.imageItem.type === \"background\"\r\n    //           ? pageStore.presetHeight * 3.78\r\n    //           : 150,\r\n    //     };\r\n\r\n    //     const newElement = this.elementMachanism(data);\r\n\r\n    //     if (this.pendingImageSide === \"front\") {\r\n    //       this.frontBoxes.push(newElement);\r\n    //     } else {\r\n    //       this.backBoxes.push(newElement);\r\n    //     }\r\n    //     this.pendingImagePosition = null;\r\n    //     this.pendingImageSide = null;\r\n    //     this.selectedElement = newElement.id;\r\n    //     this.updateProperties();\r\n    //   }\r\n    // },\r\n\r\n    handleQRCodeGenerator(qrcodeValue: string) {\r\n      const qrcodeData = {\r\n        value: qrcodeValue,\r\n        variant: \"pixelated\",\r\n        radius: 1,\r\n        blackColor: \"#000000\", // 'var(--ui-text-highlighted)' if you are using `@nuxt/ui` v3\r\n        whiteColor: \"transparent\",\r\n      };\r\n      const data = {\r\n        item: {\r\n          text: \"\",\r\n          type: \"qrcode\",\r\n          label: \"QR Code\",\r\n        },\r\n        position: {\r\n          left: 43,\r\n          top: 188,\r\n        },\r\n        width: 150,\r\n        height: 150,\r\n        qrcode: qrcodeData,\r\n      };\r\n\r\n      const newElement = this.elementMachanism(data);\r\n\r\n      this.addElement(newElement);\r\n      this.selectedElement = newElement.id;\r\n      this.updateProperties();\r\n    },\r\n\r\n    updateProperties(newProperties?: Partial<ElementProperties>) {\r\n      if (this.selectedElement === null) {\r\n        this.currentProperties = {};\r\n        return;\r\n      }\r\n      const element = this.boxes.find((e) => e.id === this.selectedElement);\r\n      if (!element) return;\r\n\r\n      if (newProperties) {\r\n        element.position.left = newProperties.x ?? element.position.left;\r\n        element.position.top = newProperties.y ?? element.position.top;\r\n        element.properties = { ...element.properties, ...newProperties };\r\n        element.text = newProperties.text ?? element.text;\r\n      }\r\n      this.currentProperties = {\r\n        x: Math.floor(element.position.left),\r\n        y: Math.floor(element.position.top),\r\n        size: { ...element.properties.size },\r\n        rotation: element.properties.rotation,\r\n        font: element.properties.font,\r\n        fontWeight: element.properties.fontWeight,\r\n        fontStyle: element.properties.fontStyle,\r\n        fontSize: element.properties.fontSize,\r\n        fillColor: element.properties.fillColor,\r\n        fillTransparency: element.properties.fillTransparency,\r\n        textDecoration: element.properties.textDecoration,\r\n        color: element.properties.color,\r\n        textAlign: element.properties.textAlign,\r\n        verticalAlign: element.properties.verticalAlign,\r\n        horizontalAlign: element.properties.horizontalAlign,\r\n        textTransform: element.properties.textTransform,\r\n        src: element.properties.src,\r\n        strokeColor: element.properties.strokeColor,\r\n        strokeWidth: element.properties.strokeWidth,\r\n        associatedData: element.properties.associatedData,\r\n        content: element.properties.content,\r\n        text: element.text,\r\n        displayOption: element.properties.displayOption,\r\n        qrcode: element.properties.qrcode,\r\n        direction: element.properties.direction,\r\n      };\r\n    },\r\n\r\n    updateElementText(id: string | number, newText: string) {\r\n      const boxes =\r\n        this.activeSide === \"front\" ? this.frontBoxes : this.backBoxes;\r\n      const element = boxes.find((e) => e.id === id);\r\n      if (element) {\r\n        element.text = newText;\r\n        element.properties.text = newText;\r\n      }\r\n    },\r\n\r\n    alignHorizontal(alignment: \"left\" | \"center\" | \"right\") {\r\n      if (this.selectedElement === null || !this.dropzone) return;\r\n      const element = this.boxes.find((e) => e.id === this.selectedElement);\r\n      if (!element) return;\r\n      const canvasRect = this.dropzone.getBoundingClientRect();\r\n      const elementWidth = element.properties.size.width;\r\n      switch (alignment) {\r\n        case \"left\":\r\n          element.position.left = 0;\r\n          element.properties.textAlign = \"left\";\r\n          element.properties.horizontalAlign = \"left\";\r\n          break;\r\n        case \"center\":\r\n          element.position.left = (canvasRect.width - elementWidth) / 2;\r\n          element.properties.textAlign = \"center\";\r\n          element.properties.horizontalAlign = \"center\";\r\n          break;\r\n        case \"right\":\r\n          element.position.left = canvasRect.width - elementWidth;\r\n          element.properties.textAlign = \"right\";\r\n          element.properties.horizontalAlign = \"right\";\r\n          break;\r\n      }\r\n      this.currentProperties.x = element.position.left;\r\n      this.currentProperties.textAlign = alignment;\r\n      this.currentProperties.horizontalAlign = alignment;\r\n      this.updateProperties(this.currentProperties);\r\n    },\r\n\r\n    alignVertical(alignment: \"top\" | \"middle\" | \"bottom\") {\r\n      if (this.selectedElement === null || !this.dropzone) return;\r\n      const element = this.boxes.find((e) => e.id === this.selectedElement);\r\n      if (!element) return;\r\n      const canvasRect = this.dropzone.getBoundingClientRect();\r\n      const elementHeight = element.properties.size.height;\r\n      switch (alignment) {\r\n        case \"top\":\r\n          element.position.top = 0;\r\n          element.properties.verticalAlign = \"top\";\r\n          break;\r\n        case \"middle\":\r\n          element.position.top = (canvasRect.height - elementHeight) / 2;\r\n          element.properties.verticalAlign = \"middle\";\r\n          break;\r\n        case \"bottom\":\r\n          element.position.top = canvasRect.height - elementHeight;\r\n          element.properties.verticalAlign = \"bottom\";\r\n          break;\r\n      }\r\n      this.currentProperties.y = element.position.top;\r\n      this.currentProperties.verticalAlign = alignment;\r\n      this.updateProperties(this.currentProperties);\r\n    },\r\n\r\n    makeTransparent(color: string) {\r\n      if (color === \"fillColor\") {\r\n        this.currentProperties.fillTransparency = true;\r\n        this.currentProperties.fillColor = \"transparent\";\r\n        this.updateProperties(this.currentProperties);\r\n      } else {\r\n        this.currentProperties.color = \"transparent\";\r\n        this.updateProperties(this.currentProperties);\r\n      }\r\n    },\r\n\r\n    applyTextAlign(align: string) {\r\n      this.currentProperties.textAlign = align;\r\n      this.currentProperties.horizontalAlign = align;\r\n      const element = this.boxes.find((e) => e.id === this.selectedElement);\r\n      if (element) {\r\n        element.properties.textAlign = align;\r\n        element.properties.horizontalAlign = align;\r\n      }\r\n      this.updateProperties(this.currentProperties);\r\n    },\r\n\r\n    applyVerticalAlign(align: string) {\r\n      this.currentProperties.verticalAlign = align;\r\n      const element = this.boxes.find((e) => e.id === this.selectedElement);\r\n      if (element) {\r\n        element.properties.verticalAlign = align;\r\n      }\r\n      this.updateProperties(this.currentProperties);\r\n    },\r\n\r\n    applyTextTransform(transform: string) {\r\n      this.currentProperties.textTransform = transform;\r\n      this.updateProperties(this.currentProperties);\r\n    },\r\n\r\n    toggleTextStyle(style: \"bold\" | \"italic\" | \"underline\") {\r\n      if (style === \"bold\") {\r\n        this.currentProperties.fontWeight =\r\n          this.currentProperties.fontWeight === \"bold\" ? \"normal\" : \"bold\";\r\n      } else if (style === \"italic\") {\r\n        this.currentProperties.fontStyle =\r\n          this.currentProperties.fontStyle === \"italic\" ? \"normal\" : \"italic\";\r\n      } else if (style === \"underline\") {\r\n        this.currentProperties.textDecoration =\r\n          this.currentProperties.textDecoration === \"underline\"\r\n            ? \"none\"\r\n            : \"underline\";\r\n      }\r\n      this.updateProperties(this.currentProperties);\r\n    },\r\n\r\n    toggleLayerVisibility(id: string | number) {\r\n      const boxes =\r\n        this.activeSide === \"front\" ? this.frontBoxes : this.backBoxes;\r\n      const el = boxes.find((e) => e.id === id);\r\n      if (el) el.visible = !el.visible;\r\n    },\r\n\r\n    selectLayer(id: string | number) {\r\n      this.selectedElement = id;\r\n      this.updateProperties();\r\n    },\r\n\r\n    setTextDirection(id: string | number, direction: \"ltr\" | \"rtl\") {\r\n      const element = this.boxes.find((e) => e.id === id);\r\n      if (element) {\r\n        element.properties.direction = direction;\r\n        this.currentProperties.direction = direction;\r\n        this.updateProperties(this.currentProperties);\r\n      }\r\n    },\r\n\r\n    setBackground(background: string | null, side: \"front\" | \"back\") {\r\n      if (side === \"front\") {\r\n        this.frontBackground = background;\r\n      } else {\r\n        this.backBackground = background;\r\n      }\r\n    },\r\n\r\n    applyGradient(gradient: string, side: \"front\" | \"back\") {\r\n      this.setBackground(gradient, side);\r\n      this.showGradientModal = false;\r\n    },\r\n\r\n    applyColor(color: string, side: \"front\" | \"back\") {\r\n      this.setBackground(color, side);\r\n      this.showColorModal = false;\r\n    },\r\n  },\r\n  persist: true,\r\n});\r\n"],"names":["toReactive","objectRef","isRef","reactive","proxy","_","p","receiver","unref","value","reactiveComputed","fn","computed","noop","toRef","args","toRef$1","r","readonly","customRef","ref","reactivePick","obj","keys","flatKeys","predicate","toRefs$1","k","v","toValue$1","QrCodeDataType","QrCodeDataType2","__defProp","__defNormalProp","key","__publicField","LOW","MEDIUM","QUARTILE","HIGH","EccMap","NUMERIC_REGEX","ALPHANUMERIC_REGEX","ALPHANUMERIC_CHARSET","MIN_VERSION","MAX_VERSION","PENALTY_N1","PENALTY_N2","PENALTY_N3","PENALTY_N4","ECC_CODEWORDS_PER_BLOCK","NUM_ERROR_CORRECTION_BLOCKS","QrCode","version","ecc","dataCodewords","msk","row","i","allCodewords","minPenalty","penalty","x","y","alignPatPos","numAlign","j","mask","data","rem","bits","getBit","color","a","b","dy","dx","dist","xx","yy","isDark","type","ver","ecl","getNumDataCodewords","numBlocks","blockEccLen","rawCodewords","getNumRawDataModules","numShortBlocks","shortBlockLen","blocks","rsDiv","reedSolomonComputeDivisor","dat","reedSolomonComputeRemainder","result","block","right","vert","invert","runColor","runX","runHistory","runY","dark","sum","total","step","pos","core","currentRunColor","currentRunLength","appendBits","val","len","bb","QrSegment","mode","numChars","bitData","MODE_NUMERIC","MODE_ALPHANUMERIC","MODE_BYTE","numCharCountBits","makeBytes","makeNumeric","digits","isNumeric","n","makeAlphanumeric","text","isAlphanumeric","temp","makeSegments","toUtf8ByteArray","getTotalBits","segs","seg","ccbits","str","degree","root","reedSolomonMultiply","divisor","factor","coef","z","encodeSegments","minVersion","maxVersion","boostEcl","dataUsedBits","dataCapacityBits2","usedBits","newEcl","dataCapacityBits","padByte","encode","options","boostEcc","maskPattern","border","segment","qr","addBorder","mod","input","size","newSize","getColors","whiteColor","blackColor","getSize","pixelSize","DEFAULT_PIXEL_SIZE","getRadius","radius","defRadius","DEFAULT_RADIUS","pixelRadius","outer","inner","getVariant","variant","defVariant","pixelVariant","limitInput","number","renderUtils","qrSize","qrBorder","innerSize","markerSize","markerPositions","isInMarkerRange","markerStart","col","DEFAULT_PADDING","renderDotPixel","padding","svg","clampedRadius","clampedPadding","actualPadding","actualSize","actualRadius","createDotPixel","renderDotMarkerOuter","_x","_y","renderDotMarkerInner","adjustedX","adjustedY","adjustedSize","renderCircleMarkerOuter","_size","maxOuterRadius","outerRadius","renderCircleMarkerInner","renderDefaultPixel","pixelPaths","renderDefaultMarkerOuter","outerPaths","renderDefaultMarkerInner","renderPixelatedPixel","foregroundColor","notchSize","paths","addNotches","renderPixelatedMarkerOuter","renderPixelatedMarkerInner","checkPixel","c","notches","renderRoundedPixel","visited","tracePath","renderRoundedMarkerOuter","outerPath","createRoundedRectPath","innerPath","createReversedRoundedRectPath","renderRoundedMarkerInner","path","startRow","startCol","cornerRadius","stack","top","bottom","left","createPixelPath","commands","adjustedRadius","curve","width","height","renderMarkers","ox","oy","ix","iy","markerOuterVariants","markerInnerVariants","renderPixels","renderSVGBody","pixelPadding","backgroundColor","svgBody","markerRadius","markerVariant","__nuxt_component_0","defineComponent","props","attrs","emit","_options","valueRef","defu","useRuntimeConfig","preserveAspectRatio","opts","qr2","s","h","useCanvasStore","defineStore","state","item","position","pageStore","usePageStore","canvasWidth","canvasHeight","elementWidth","elementHeight","adjustedPosition","newElement","dataUrl","customPosition","element","qrcodeValue","newProperties","e","id","newText","alignment","canvasRect","align","transform","style","el","direction","background","side","gradient"],"mappings":"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"}